<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<!-- edited with XMLSPY v5 rel. 3 U (http://www.xmlspy.com)
     by Daniel M Kohn (private) -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" docName="draft-ietf-alto-new-transport-07" ipr="trust200902" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" symRefs="true" sortRefs="true" version="3" consensus="true">
  <!-- xml2rfc v2v3 conversion 3.12.10 -->
  <?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

  <front>
    <title abbrev="ALTO TIPS">ALTO Transport Information Publication Service</title>
    <seriesInfo name="Internet-Draft" value="draft-ietf-alto-new-transport-07"/>
    <author fullname="Roland Schott" initials="R." surname="Schott">
      <organization>Deutsche Telekom</organization>
      <address>
        <postal>
          <street>Heinrich-Hertz-Strasse 3-7</street>
          <city>64295 Darmstadt</city>
          <country>Germany</country>
        </postal>
        <email>Roland.Schott@telekom.de</email>
      </address>
    </author>
    <author fullname="Y. Richard Yang" initials="Y." surname="Yang">
      <organization>Yale University</organization>
      <address>
        <postal>
          <street>51 Prospect St</street>
          <city>New Haven</city>
          <region>CT</region>
          <code>06520</code>
          <country>USA</country>
        </postal>
        <email>yry@cs.yale.edu</email>
      </address>
    </author>
    <author fullname="Kai Gao" initials="K." surname="Gao">
      <organization>Sichuan University</organization>
      <address>
        <postal>
	  <street>No.24 South Section 1, Yihuan Road</street>
          <city>Chengdu</city>
	  <region>Sichuan</region>
          <code>610065</code>
          <country>China</country>
        </postal>
        <email>kgao@scu.edu.cn</email>
      </address>
    </author>
    <author fullname="Lauren Delwiche" initials="L." surname="Delwiche">
      <organization>Yale University</organization>
      <address>
        <postal>
          <street>51 Prospect St</street>
          <city>New Haven</city>
          <region>CT</region>
          <code>06520</code>
          <country>USA</country>
        </postal>
        <email>lauren.delwiche@yale.edu</email>
      </address>
    </author>
    <author fullname="Lachlan Keller" initials="L." surname="Keller">
      <organization>Yale University</organization>
      <address>
        <postal>
          <street>51 Prospect Street</street>
          <city>New Haven</city>
          <code>06511</code>
          <country>USA</country>
        </postal>
        <email>lachlan.keller@yale.edu</email>
      </address>
    </author>
    <date day="25" month="February" year="2023"/>
    <area>TSV Area</area>
    <workgroup>ALTO Working Group</workgroup>
    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>Application-Layer Traffic Optimization, HTTP/2, HTTP/3, SSE, Updates Graph</keyword>
    <abstract>
      <t>   
      The ALTO protocol (RFC 7285) leverages HTTP/1.x and is designed for the simple, 
      sequential request-reply use case, in which an ALTO client requests a
      sequence of information resources, and the server responds with the complete 
      content of each resource one at a time.  
      </t>
      
      <t>
      ALTO/SSE (RFC 8895) defines a multiplexing protocol on top 
      of HTTP/1.x, so that the server can incrementally push resource updates 
      to the client whenever monitored network information resources change, allowing the
      client to monitor multiple resources at the same time.  
      However, HTTP/2 and later versions already support concurrent, non-blocking transport of
      multiple streams in the same HTTP connection.
      </t>

      <t>
      To take advantage of newer HTTP features, this document introduces the ALTO Transport 
      Information Publication Service (TIPS).  TIPS uses an incremental RESTful design to
      give an ALTO client the new capability to explicitly, concurrently (non-blocking) request (pull)
      specific incremental updates using native HTTP/2 or HTTP/3, while still
      functioning for HTTP/1.x.  It also provides an ALTO server the new capability 
      to concurrently push specific incremental updates using native HTTP/2 or HTTP/3 
      server push.                 
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Application-Layer Traffic Optimization (ALTO) provides means for
       network applications to obtain network status information.  So far,
       two transport protocols have been designed: (1) The ALTO base
       protocol <xref target="RFC7285" format="default"/>, which is designed for the simple use case in
       which an ALTO client requests a network information resource, and the
       server sends the complete content of the requested information
       resource to the client; and (2) ALTO/SSE (ALTO Incremental Updates
       Using Server-Sent Events) <xref target="RFC8895" format="default"/>, 
       which is designed for the use case that an ALTO client indicates to the server that it wants to
       receive updates for a set of resources, and the server can then
       concurrently, and incrementally push updates to the client whenever
       monitored resources change.</t>

   
      <t>Both protocols are designed for HTTP/1.x <xref target="RFC9112" format="default"/> and, ideally, 
        they should be able to automatically take advantage of newer HTTP 
        versions such as HTTP/2 <xref target="RFC9113" format="default"/> 
        and HTTP/3 <xref target="RFC9114" format="default"/>.  However, 
        there are issues with both protocols when HTTP moves to higher versions.  
        First consider the ALTO base protocol, which is designed to transfer 
        only complete information resources.  Hence, a client can run the 
        base protocol on top of HTTP/2 or HTTP/3 to request multiple information 
        resources concurrently, in concurrent streams, but each request must be 
        for a complete information resource; there is no capability of 
        transferring incremental updates.  Hence, there can be large overhead 
        when the client already has an information resource and then there are 
        small changes to the resource.  Next, consider ALTO/SSE.  Although ALTO/SSE
        can transfer incremental updates, it introduces a customized
        multiplexing protocol on top of HTTP, assuming a total-order message
        channel from the server to the client.  The multiplexing design does
        not provide naming (i.e., providing resource identifier) to
        individual incremental updates.  Hence, the design cannot use
        concurrent per-stream server push or non-blocking per-stream client
        pull, available in HTTP/2 and HTTP/3, because both cases require the
        resource identifier. Additionally, ALTO/SSE is a push-only protocol,
        which denies the client flexibility in choosing how and when it 
        receives updates. 
      </t>

      <t>This document introduces a new ALTO service called the transport
        information publication service (TIPS).  TIPS uses an incremental RESTful design to
        give an ALTO client the new capability to explicitly, concurrently (non-blocking) request (pull)
        specific incremental updates using native HTTP/2 or HTTP/3, while still
        functioning for HTTP/1.x.  It also provides an ALTO server the new capability 
        to concurrently push specific incremental updates using native HTTP/2 or HTTP/3 
        server push. This document specifies the following:</t>
      <ul>
        <li>ALTO protocol extensions to create/update/remove an incremental representational 
        state transfer resource (iREST);</li> 
        <li>A new resource type that specifies the iREST graph model for a resource;</li>
        <li>URI patterns to fetch the snapshots or incremental updates.</li>
      </ul>

      <section anchor="requirements-language" numbered="true" toc="default">
        <name>Requirements Language</name>
        <t>
            The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
            "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY",
            and "OPTIONAL" in this document are to be interpreted as described
            in BCP 14 <xref target="RFC2119" format="default"/><xref target="RFC8174" format="default"/> 
            when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>

      <section anchor="notations" numbered="true" toc="default">
        <name>Notations</name>
        <t>This document uses the same syntax and notations as introduced in Section 8.2 of
            RFC 7285 <xref target="RFC7285" format="default"/> to specify the extensions to existing ALTO resources and
            services.
        </t>
      </section>
    </section> <!-- End Intro-->

    <section anchor="altoh2overview" numbered="true" toc="default">
      <name>TIPS Overview</name>

      <section anchor="basic-data-model" numbered="true" toc="default">
      <name>Basic Data Model: Incremental Representation State Transfer (iREST)</name>

      <t>For each resource (e.g., a cost map, network map), the incremental
      updates and snapshots can be represented using the following directed acyclic graph model,
      where the server maps base resource IDs to incremental update IDs that are assigned sequentially:</t>
      <ul>
        <li>Each node in the graph is a version of the resource, where a tag identifies 
        content of version (tag is valid only within the scope of resource). 
        Version 0 is reserved as the initial state (empty/null).</li>
        <li>Each edge is transport data (update item). In particular, edge from i to j is
        the (op, data) to transition version from version i to version j.</li>
        <li>Node content is path independent (different paths arrive at the same content)</li>
      </ul>
      <t>A concrete example is as shown in <xref target="data-model" format="default"/>.
      Thick lines represent incremental updates and thin lines represent snapshots.  
      Note that node content is path independent: the content can be obtained 
      by applying the updates from different paths.  For example, assume the client already has version at 103: the version at 105
      can either be directly fetched as a snapshot or computed incrementally by applying the incremental updates between 
      103 and 104, then 104 and 105.</t>

      <figure anchor="data-model">
        <name>iREST Model Example</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
                                          +======+                                   
                                          |  0   |                                   
                                          +======+                                   
                                          /   |  \
                                ID0-101  /    |   |
                                        /     |   |
                                      |/__    |   |
                                +======+      |   |                            
                    tag: 1.1 -> | 101  |      |   |                           
                                +======+      |   |                            
                                   ||         |   | 
                        ID101-102  ||         |   | 
                                   \/         |   | 
                                +======+      |   |                            
                    tag: 1.5 -> | 102  |      |   |                                   
                                +======+      |   |
                                   ||         |   |
                        ID102-103  ||  ID0-103|   |
                                   \/         |   |
                                +======+      /   |                                   
+---------------+   tag: 2.0 -> | 103  |<----/    |                                  
| Base Resource |  =====>       +======+          |
+---------------+                  ||             |
                        ID103-104  ||             |
                                   \/             |
                                +======+          |                                   
                    tag: 3.0 -> | 104  |          |                                   
                                +======+          |                                  
                                   ||             | ID0-105
                        ID104-105  ||             |
                                   \/             /
                                +======+         /                                   
                    tag: 3.3 -> | 105  |<-------/                                    
                                +======+ 
                                   ||
                        ID105-106  ||
                                   \/
                                +======+                                   
                    tag: 3.7 -> | 106  |                                   
                                +======+ 
                   
          tag: denotes the version of the resource at node i
          ID###-###: denotes update item (op, data) to transition from 
                     version at node i to version at node j
      
      ]]></artwork>
      </figure>

      <section anchor="location-schema" numbered="true" toc="default">
        <name>iREST Resource Location Schema</name>
        <t>To access each individual update, consider the model represented
        as a "virtual" file system (adjacency list).</t>
        <figure anchor="location-schema-fig">
        <name>Location Schema for <xref target="data-model" format="default"/>.</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
            
      <tips-view-uri>
          ug    // updates graph
              0
                  101    // full 101 content
                  103
                  105
              101
                  102    // 101 -> 102 patch
              102
                  103
              103
                  104
              104
                  105
              105
                  106
      

      Location -> resource naming (ID assignment)
        - <tips-view-uri>/ug/<i>/<j>

      Client Pull:
        GET /<tips-view-uri>/ug/0/105
        GET /<tips-view-uri>/ug/105/106
      
      Server Push:
        Use the URI as above
      
      ]]></artwork>
        </figure>
        <t> Due to the sequential nature of the update patch IDs, a client can long pull a future update
        that does not yet exist (e.g., the patch from 106 to 107) by constructing the URI:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
    GET /<tips-view-uri>/ug/<end-seq>/<end-seq + 1>
             ]]></artwork>

        </section>
    </section>
      <section anchor="service-model" numbered="true" toc="default">
        <name>High-level Service Model</name>

        <t>Conceptually, the TIPS system consists of 3 types of resources:</t>
        <ul>
            <li>(R1) TIPS frontend to manage (create/delete) TIPS views.</li>
            <li>(R2) TIPS view directory, which provides metadata (e.g., references) about the network resource data.</li>
            <li>(R3) The actual network resource data, encoded as complete ALTO network resources (e.g., cost map, network map) or incremental updates.</li>
        </ul>

        <figure anchor="service-model-figure">
          <name>Service Model</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[

                     +------------------------------------------------+
                     |                                                |
+------+             |R1: Frontend/Open  R2: Directory/Meta  R3: Data |
|      | "iget" base |     +-----+           +-----+         +-----+  |
|      | resource 1  |     |     |           |     |         |     |  | 
|      |-------------|---->|     |           |     |         |     |  |  
|      | incremental |     |     |           |     |-------->|     |  | 
|      | transfer    |     |     |           |     |         |     |  | 
|      | resource    |     |     |           |     |         |     |  | 
|      |<------------|-----|     |           +-----+         +-----+  | 
|Client|             |     |     |                                    | 
|      | "iget" base |     |     |                                    | 
|      | resource 2  |     |     |           +-----+         +-----+  | 
|      |-------------|---->|     |           |     |         |     |  | 
|      | incremental |     |     |           |     |         |     |  | 
|      | transfer    |     |     |           |     | ------->|     |  | 
|      | resource    |     |     |           |     |         |     |  | 
|      |<------------|-----|     |           |     |         |     |  | 
+------+             |     +-----+           +-----+         +-----+  |     
                     |                                                |
                     +------------------------------------------------+
      
      ]]></artwork>
        </figure>
      
      <t>Design Point: Component Resource Location</t>
        <ul>
            <li>Design 1 (Single): all 3 types at the same, single server (accessed via relative reference)</li>
            <li>Design 2 (Flexible): all 3 types can be at their own server (accessed via absolute reference)</li>
            <li>Design 3 (Dir + Data): R2 and R3 must remain together, though R1 might not be on the same server</li>
        </ul>
      <t>This document specifies Design 1 (keeping R1, R2, and R3 on the same server) in order to simplify session management,
      though at the expense of maximum load balancing flexibility (see <xref target="ops-loadbalancing" format="default"/> for a discussion on load balancing considerations). 
      A future companion document may extend the protocol to support Design 2 or Design 3.</t>     

      </section>

      <section anchor="tipsinfo-terms" numbered="true" toc="default">
        <name>TIPS Terminology</name>

        <t>This document uses the following components:</t>
        <dl newline="true" spacing="normal" indent="3">

          <dt>Network information resource:</dt>
          <dd>A piece of retrievable information about network state, per <xref target="RFC7285" format="default"/>.</dd>

          <dt>TIPS view (ts):</dt>
          <dd>Defined in this document to be the container of incremental transport information 
          about the network information resource.  Though the TIPS view 
          may include other transport information, it has two basic components: updates graph (ug) 
          and receiver set (rs).</dd>

          <dt>Updates graph (ug):</dt>
          <dd> Contains a sequence of incremental updates and snapshots (called update items) of a network information resource,
          based on the iREST model defined above.  Each incremental update is assigned a sequence number, and a 
          URI can be constructed using the sequence numbers.  A static network information resource (e.g., Cost Map, Network
          Map) may need only a single updates graph.  A dynamic network
          information resource (e.g., Filtered Cost Map) may create an
          updates graph (within a new TIPS view) for each unique filter request.</dd>

          <dt>Receiver set (rs):</dt>
          <dd>The receiver set contains the set of clients who have requested to receive server push updates.</dd>

          <dt>Information Resource Directory (IRD):</dt>
          <dd>Requested by an ALTO client to discover available information resources provided by an 
          ALTO server, per <xref target="RFC7285" format="default"/>.  
          Each entry in an IRD indicates a URI at which an ALTO server 
          accepts requests, and returns either an information resource or an information resource 
          directory that references additional information resources.  An ALTO server's IRD MAY 
          define one or more transport information publication services, which ALTO clients use 
          to request new TIPS instances.</dd>

        </dl>
        <t>Figure 1 shows an example illustrating the TIPS abstraction.
           Each ALTO client (Client 1, Client 2, or Client 3) 
           maintains a single HTTP connection with the ALTO server.
        </t>

        <figure anchor="FigInfoStruct">
          <name>ALTO Transport Information</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[

Network Information Resource:

a) Static resource (#1) such as NetworkMap
b) Filterable resource (#3) such as FilteredCostMap


                                   +-------------+
    +-----------+ +--------------+ |  Dynamic    | +-----------+
    |  Routing  | | Provisioning | |  Network    | | External  |
    | Protocols | |    Policy    | | Information | | Interface |
    +-----------+ +--------------+ +-------------+ +-----------+
          |              |                |              |
          |              |                |              |
+----------------------------------------------------------------------+
| ALTO Server                                                          |
|                                                                      |
| +------------------------------------------------------------------+ |
| |                                              Network Information | |
| |                                                                  | |
| | +-------------+     +-------------+     +-------------+          | |
| | | Information |     | Information |     | Information |          | |
| | | Resource #1 |     | Resource #2 |     | Resource #3 |          | |
| | +-------------+     +-------------+     +-------------+          | |
| |     |                                       /     \              | |
| +-----|--------------------------------------/-------\-------------+ |
|       |                                     /         \              |
| +-----|------------------------------------/-----------\-----------+ |
| |     |       Transport Information       /             \          | |
| |     |                                  /               \         | |
| | +--------+                     +--------+        +--------+      | |
| | |  tv1   |----+          +-----|  tv2   |        |  tv3   |---+  | |
| | +--------+    |          |     +--------+        +--------+   |  | |
| |     |         |          |           |             |          |  | |
| | +--------+ +--------+ +--------+ +--------+ +--------+ +--------+| |
| | | tv1/ug | | tv1/rs | | tv2/ug | | tv2/rs | | tv3/ug | | tv3/rs || |
| | +--------+ +--------+ +--------+ +--------+ +--------+ +--------+| |
| +----|\---------/\---------|---------/---------------|-------------+ |
|      | \       /  \        |        /                |               |
+------|--\-----/----\-------|-------/-----------------|---------------+
       |   \   /      \      |      /                  |       
       |    +-/-----+  \     |     /                   |
       |     /       \  \    |    /  A single          |   A single
       |    /       ==\==\===|===/== HTTP/2 or /3    ==|== HTTP/1.x
       |   /           \  \  |  /    connection        |   connection
   +----------+       +----------+                 +----------+
   | Client 1 |       | Client 2 |                 | Client 3 |
   +----------+       +----------+                 +----------+

tvi   = TIPS view i
tvi/ug = incremental updates graph associated with tsi
tvi/rs = receiver set of tvi (for server push)

      ]]></artwork>
        </figure>
      </section>

      <section anchor="tipsinfo-workflow" numbered="true" toc="default">
        <name>TIPS Workflow</name>

        <t>The intended use case of TIPS is to run it as a service
           inside an HTTP/2 or HTTP/3 connection (though it can run inside
           an HTTP/1.x connection, without server push functionality).  
           Specifically, an ALTO client opens an HTTP connection with an ALTO server and uses 
           TIPS to retrieve a JSON object that contains a URI to a TIPS view of each network 
           information resource that the client wants to monitor, along with a summary of each TIPS view
           (which provides, at minimum, the start and end sequence number of the updates graph
           and a server-recommended edge to consume first). 
        </t>

        <t>In the simplest use case, the TIPS view summary provides enough
           information for the client to continuously pull each additional
           update, resulting in the following workflow:
        </t>

        <figure anchor="FigInfoWorkflowPull">        
          <name>ALTO TIPS Workflow Supporting Client Pull.</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Client                                  TIPS         
  o                                       .           
  | Open HTTP connection                  .           
  |-------------------------------------->|           
  |                                       .           
  | POST to create/receive a TIPS view    .           
  |           for resource 1              .           
  | ------------------------------------> |           
  | <tips-view-uri1>, <tips-view-summary> .           
  |<------------------------------------- |           
  |                                       .           
  | GET /<tips-view-uri1>/ug/<i>/<j>      .
  | --------------------------------------|
  | content on edge i to j                .           
  |<--------------------------------------|
  |                                       .           
  | GET /<tips-view-uri1>/ug/<j>/<j+1>    .           
  | --------------------------------------|
  | content on edge j to j+1              .           
  |<--------------------------------------|
  |                                       .
  | DELETE TIPS view for resource 1       .
  |-------------------------------------> |
  |                                       .
  | Close HTTP connection                 .
  |-------------------------------------->|
  o

  TIPS: Transport Information Publication Service

      ]]></artwork>
      </figure>        

      <t>A client that prefers server push can use the following workflow:</t>
        <figure anchor="FigInfoWorkflowPush">        
          <name>ALTO TIPS Workflow Supporting Server Push.</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Client                                  TIPS         
  o                                       .           
  | Open HTTP connection                  .           
  |-------------------------------------->|           
  |                                       .           
  | POST to create/receive a TIPS view    .           
  |      for resource 1 and add           .           
  |      self to receiver set             .           
  | ------------------------------------> |           
  | <tips-view-uri1>, <tips-view-summary> .           
  |<------------------------------------- |           
  |                                       .           
  | PUSH <tips-view-uri1>/ug/<i>/<j>      .           
  | <-------------------------------------|
  |                                       . 
  | PUSH <tips-view-uri1>/ug/<j>/<j+1>    .           
  | <-------------------------------------|
  |                                       .
  | PUT to remove self from receiver      . 
  |      set of resource 1                .
  |-------------------------------------> |
  |                                       .
  | Close HTTP connection                 .
  |-------------------------------------->|
  o

  TIPS: Transport Information Publication Service

        ]]></artwork>
        </figure>

      </section>

      <section anchor="tipsinfo-http1" numbered="true" toc="default">
        <name>TIPS With HTTP/1.x</name>

        <t>
            While TIPS is designed to take advantage of newer HTTP features,
            TIPS still functions with HTTP/1.x for client pull functionality only,
            with the limitation that it cannot cancel any outstanding requests or 
            fetch resources concurrently over the same connection.  
        </t>

      </section>
    </section>
    <!-- end of overview -->

    <section anchor="tips-ird" numbered="true" toc="default">
      <name>TIPS Information Resource Directory (IRD) Announcement</name>

      <t>An ALTO server's IRD (Information Resource Directory) MAY define
          one or more transport information publication services, which 
          ALTO clients use to request new TIPS instances.  An IRD entry 
          defining a TIPS MUST declare the "media-type", and specify
          "capabilities" and "uses" as follows.
      </t>

      <section anchor="tips-media-type" numbered="true" toc="default">
        <name>Media Type</name>
        <t>The media type of the Transport Information Publication Service resource is
          "application/alto-tips+json".
        </t>
        </section>

        <section anchor="tips-cap" numbered="true" toc="default">
          <name>Capabilities</name>
          <t>The capabilities declaration of TIPS is modelled on that defined 
            in Section 6.3 of <xref target="RFC8895" format="default"/>.
          </t>

        <t>Specifically, the capabilities are defined as an object of 
          type TIPSCapabilities:
        </t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
     object {
       IncrementalUpdateMediaTypes incremental-change-media-types;
       Boolean                     support-server-push;
     } TIPSCapabilities;

     object-map {
        ResourceID -> String;
     } IncrementalUpdateMediaTypes;
        ]]></artwork>

        <t>with field:</t>
        <dl>
          <dt>incremental-change-media-types: </dt>
          <dd>
          <t>If a TIPS can provide updates with incremental changes 
              for a resource, the "incremental-change-media-types" field has an 
              entry for that resource-id, and the value is the
              supported media types of the incremental change separated by commas.
              For the implementation of this specification, this will be 
              "application/merge-patch+json", "application/json-patch+json", 
              or "application/merge-patch+json,application/json-patch+json".  
              Future extensions may define other types of incremental changes.
          </t>

          <t>When choosing the media types to encode incremental updates for a
              resource, the server MUST consider the limitations of
              the encoding.  For example, when a JSON merge patch specifies that
              the value of a field is null, its semantics are that the field is
              removed from the target and hence the field is no longer defined
              (i.e., undefined).  This, however, may not be the intended
              result for the resource, when null and undefined have different
              semantics for the resource.  In such a case, the server
              MUST choose JSON patch over JSON merge patch if JSON patch is
              indicated as a capability of the TIPS.  If the server
              does not support JSON patch to handle such a case, the server then
              needs to send a full replacement.
          </t>
          </dd>
          <dt>support-server-push: </dt>
          <dd>
          <t>The "support-server-push" field specifies whether the given TIPS
              supports server push.  If the "support-server-push"
              field is "true", this TIPS will allow a client to start or stop server
          push.</t>
          </dd>
        </dl>
      </section>

      <section anchor="tips-uses" numbered="true" toc="default">
        <name>Uses</name>
          <t>The "uses" attribute MUST be an array with the resource-ids of every
              network information resource for which this TIPS can provide service. </t>

          <t>This set may be any subset of the ALTO server's network information resources and may
              include resources defined in linked IRDs.  However, it is RECOMMENDED
              that the ALTO server selects a set that is closed under the resource
              dependency relationship.  That is, if a TIPS' "uses" set
              includes resource R1 and resource R1 depends on ("uses") resource R0,
              then the TIPS' "uses" set SHOULD include R0 as well as R1.
              For example, a TIPS for a cost map SHOULD also provide
              a TIPS view for the network map upon which that cost map depends.
            </t>
      </section>

      <section anchor="tips-ird-example" numbered="true" toc="default">
        <name>Example</name>

        <t>Extending the IRD example in Section 8.1 of <xref target="RFC8895" format="default"/>, below is the
          IRD of an ALTO server supporting ALTO base protocol, ALTO/SSE, and
          ALTO TIPS.
        </t>

        <artwork name="" type="" align="left" alt=""><![CDATA[
    "my-network-map": {
      "uri": "https://alto.example.com/networkmap",
      "media-type": "application/alto-networkmap+json",
    },
    "my-routingcost-map": {
      "uri": "https://alto.example.com/costmap/routingcost",
      "media-type": "application/alto-costmap+json",
      "uses": ["my-networkmap"],
      "capabilities": {
        "cost-type-names": ["num-routingcost"]
      }
    },
    "my-hopcount-map": {
      "uri": "https://alto.example.com/costmap/hopcount",
      "media-type": "application/alto-costmap+json",
      "uses": ["my-networkmap"],
      "capabilities": {
        "cost-type-names": ["num-hopcount"]
      }
    },

    "my-filtered-cost-map": {
      "uri": 
        "https://alto.example.com/costmap/filtered/constraints",
      "media-type": "application/alto-costmap+json",
      "accepts": "application/alto-costmapfilter+json",
      "uses": ["my-networkmap"],
      "capabilities": {
        "cost-type-names": ["num-routingcost", "num-hopcount"],
        "cost-constraints": true
      }
    },

    "my-simple-filtered-cost-map": {
      "uri": "https://alto.example.com/costmap/filtered/simple",
      "media-type": "application/alto-costmap+json",
      "accepts": "application/alto-costmapfilter+json",
      "uses": ["my-networkmap"],
      "capabilities": {
        "cost-type-names": ["num-routingcost", "num-hopcount"],
        "cost-constraints": false
      }
    },

    "my-props": {
      "uri": "https://alto.example.com/properties",
      "media-type": "application/alto-endpointprops+json",
      "accepts": "application/alto-endpointpropparams+json",
      "capabilities": {
        "prop-types": ["priv:ietf-bandwidth"]
      }
    },

    "my-pv": {
      "uri": "https://alto.example.com/endpointcost/pv",
      "media-type": "multipart/related;
                      type=application/alto-endpointcost+json",
      "accepts": "application/alto-endpointcostparams+json",
      "capabilities": {
        "cost-type-names": [ "path-vector" ],
        "ane-properties": [ "maxresbw", "persistent-entities" ]
      }
    },

    "update-my-costs": {
      "uri": "https://alto.example.com/updates/costs",
      "media-type": "text/event-stream",
      "accepts": "application/alto-updatestreamparams+json",
      "uses": [
          "my-network-map",
          "my-routingcost-map",
          "my-hopcount-map",
          "my-simple-filtered-cost-map"
      ],
      "capabilities": {
        "incremental-change-media-types": {
          "my-network-map": "application/json-patch+json",
          "my-routingcost-map": "application/merge-patch+json",
          "my-hopcount-map": "application/merge-patch+json"
        },
        "support-stream-control": true
      }
    },

    "update-my-costs-tips": {
      "uri": "https://alto.example.com/updates-new/costs",
      "media-type": "application/alto-tips+json",
      "accepts": "application/alto-tipsparams+json",
      "uses": [
          "my-network-map",
          "my-routingcost-map",
          "my-hopcount-map",
          "my-simple-filtered-cost-map"
      ],
      "capabilities": {
        "incremental-change-media-types": {
          "my-network-map": "application/json-patch+json",
          "my-routingcost-map": "application/merge-patch+json",
          "my-hopcount-map": "application/merge-patch+json",
          "my-simple-filtered-cost-map": "application/merge-patch+json"
        },
        "support-server-push": true
      }
    },

    "update-my-props": {
      "uri": "https://alto.example.com/updates/properties",
      "media-type": "text/event-stream",
      "uses": [ "my-props" ],
      "accepts": "application/alto-updatestreamparams+json",
      "capabilities": {
        "incremental-change-media-types": {
          "my-props": "application/merge-patch+json"
        },
        "support-stream-control": true
      }
    },
    "update-my-pv": {
      "uri": "https://alto.example.com/updates/pv",
      "media-type": "text/event-stream",
      "uses": [ "my-pv" ],
      "accepts": "application/alto-updatestreamparams+json",
      "capabilities": {
        "incremental-change-media-types": {
          "my-pv": "application/merge-patch+json"
        },
        "support-stream-control": true
      }
    }
        ]]></artwork>

        <t>Note that it is straightforward for an ALTO sever to run HTTP/2 and
          support concurrent retrieval of multiple resources such as "my-
          network-map" and "my-routingcost-map" using multiple HTTP/2 streams.</t>

        <t>The resource "update-my-costs-tips" provides an ALTO TIPS based
          connection, and this is indicated by the media-type 
          "application/alto-tips+json".</t>

      </section> <!-- IRD Sec-->

    </section> <!-- TIPS IRD -->

    <section anchor="tips-create" numbered="true" toc="default">
      <name>TIPS Open/Close</name>

      <t>Upon request, a server sends a TIPS view to a client. This TIPS view may be
      created at the time of the request or may already exist (either 
      because another client has an active connection to a TIPS view for the 
      same requested network resource or because the server perpetually 
      maintains a TIPS view for an often requested resource).  The server 
      MAY keep track of which clients have an active connection 
      to each TIPS view to determine whether or not it should delete a TIPS view 
      and its corresponding updates graph and associated data. </t>

      <section anchor="tips-createreq" numbered="true" toc="default">
        <name>Open Request</name>
        <t>An ALTO client requests that the server provide a TIPS view for a 
            given resource by sending an HTTP POST body with the media type 
            "application/alto-tipsparams+json".  That body contains a JSON object 
            of type TIPSReq, where:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[

     object {
        ResourceID   resource-id;
        [JSONString  tag;]
        [Object      input;]
        [Boolean     server-push;]
     } TIPSReq;

        ]]></artwork>
        <t>with the following fields:</t>
        <dl>
          <dt>resource-id: </dt>
          <dd>
            <t>The resource-id of an ALTO resource and MUST be in the TIPS' "uses" 
                list (<xref target="tips-ird" format="default"/>).  If a client does not support all incremental methods 
                from the set announced in the server's capabilities, the client 
                MUST NOT use the TIPS service.
              </t>
          </dd>
          <dt>tag: </dt>
          <dd>
            <t>If the resource-id is a GET-mode resource with a version tag (or "vtag"), as defined in
                Sections 6.3 and 10.3 of <xref target="RFC7285" format="default"/>, and the ALTO client has
                previously retrieved a version of that resource from ALTO, 
                the ALTO client MAY set the "tag" field to the tag
                part of the client's version of that resource.  The server MAY
                use the tag when calculating a recommended starting edge for the client to consume. 
                Note that the client MUST support all incremental methods from the set 
                announced in the server's capabilities for this resource.</t>
          </dd>
          <dt>input: </dt>
          <dd>
            <t>If the resource is a POST-mode service that requires input, the
                ALTO client MUST set the "input" field to a JSON object with the
                parameters that the resource expects.
            </t>
          </dd>
          <dt>server-push: </dt>
          <dd>
            <t>Set to TRUE if a client desires to receive updates via server push.</t>
          </dd>
        </dl>
      </section>

      <section anchor="tips-createresp" numbered="true" toc="default">
        <name>Open Response</name>

        <t>The response to a valid request MUST be a JSON object of
            type AddTIPSResponse, denoted as media type "application/alto-tips+json": </t>

        <artwork name="" type="" align="left" alt=""><![CDATA[
      object {
        JSONString        tips-view-uri;
        TIPSViewSummary   tips-view-summary;
      } AddTIPSResponse;

      object {
        UpdatesGraphSummary   updates-graph-summary;
        [Boolean              server-push;]
      } TIPSViewSummary;
    
      object {
        JSONNumber       start-seq; 
        JSONNumber       end-seq;
        StartEdgeRec     start-edge-rec;                  
      } UpdatesGraphSummary;

      object {
        JSONNumber       seq-i;
        JSONNumber       seq-j;
      } StartEdgeRec;
        ]]></artwork>

        <t>with the following fields:</t>
          <dl>
            <dt>tips-view-uri: </dt>
            <dd>
              <t>Relative URI to the TIPS view of a network resource.</t>

              <t>When creating the URI for the TIPS view, TIPS MUST 
                 NOT use other properties of an HTTP request, such as cookies or 
                 the client's IP address, to determine the TIPS view.  
                 Furthermore, TIPS MUST NOT reuse a URI for a different object
                 in the same connection. 
              </t>

              <t>It is expected that there is an internal mechanism to map a 
                 tips-view-uri to the TIPS view to be accessed.
                 For example, TIPS may assign a unique, internal state id to each 
                 TIPS view instance.  However, the exact mechanism is left to 
                 the TIPS provider.
              </t>
            </dd>
            <dt>tips-view-summary: </dt>
            <dd>
              <t>Contains both an updates-graph-summary and an optional server-push boolean value 
              which is set to TRUE if the client indicated server push</t>

              <t>updates-graph-summary provides the starting sequence number of the updates graph 
              and the last sequence number (current available), along with
              a recommended edge to consume.  How the server calculates the recommended edge
              depends on the implementation.  Ideally, if the client does not provide a version
              tag, the server should recommend the edge of the latest snapshot available.  If the client
              does provide a version tag, the server should calculate the cumulative size of the 
              patch updates availabe from that version onward and compare it to the size of the 
              complete resource snapshot.  If the snapshot is bigger, the server should 
              recommend the first patch update edge starting from client's tagged version. Else,
              the server should recommend the latest snapshot edge.  If the client indicated 
              server push, the recommended edge will be the first content pushed. </t>
            </dd>
          </dl>


        <t>If the request has any errors, the TIPS service MUST return an HTTP "400 Bad 
            Request" to the ALTO client; the body of the response follows the generic 
            ALTO error response format specified in Section 8.5.2 of 
            <xref target="RFC7285" format="default"/>.  
            Hence, an example ALTO error response has the format:
        </t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
          HTTP/1.1 400 Bad Request
          Content-Length: 131
          Content-Type: application/alto-error+json
          Connection: Closed

          {
              "meta":{
                  "code":  "E_INVALID_FIELD_VALUE",
                  "field": "resource-id",
                  "value": "my-network-map/#"
              }
          }

        ]]></artwork>

        <t>Note that "field" and "value" are optional fields.  If the "value"
            field exists, the "field" field MUST exist.</t>

        <ul spacing="normal">
          <li>If the TIPS request does not have a "resource-id" field, the error    
              code of the error message MUST be E_MISSING_FIELD and the "field" 
              field SHOULD be "resource-id".  The TIPS service MUST NOT create
              any TIPS view.
          </li>

          <li>If the "resource-id" field is invalid or is not associated with
              the TIPS, the error code of the error message MUST be
              E_INVALID_FIELD_VALUE.  The "field" field SHOULD be the full path
              of the "resource-id" field, and the "value" field SHOULD be the
              invalid resource-id.
          </li>
    
          <li>If the resource is a POST-mode service that requires input, the
              client MUST set the "input" field to a JSON object with the
              parameters that that resource expects.  If the "input" field is
              missing or invalid, TIPS MUST return the same error response that  
              resource would return for missing or invalid input 
              (see <xref target="RFC7285" format="default"/>).</li>
        </ul>

      </section>

      <section anchor="tips-example" numbered="true" toc="default">
        <name>Open Example</name>
        <t>For simplicity, assume that the ALTO server is using the Basic
          authentication.  If a client with username "client1" and password
          "helloalto" wants to create a TIPS view of an ALTO Cost Map
          resource with resource ID "my-routingcost-map", it can send the
          following request:
        </t>

        <artwork name="" type="" align="left" alt=""><![CDATA[
    POST /tips HTTP/1.1
    Host: alto.example.com
    Accept: application/alto-tips+json, application/alto-error+json
    Authorization: Basic Y2xpZW50MTpoZWxsb2FsdG8K
    Content-Type: application/alto-tipsparams+json
    Content-Length: 41

    {
      "resource-id": "my-routingcost-map"
    }
        ]]></artwork>

        <t>If the operation is successful, the ALTO server returns the following message:</t>

        <artwork name="" type="" align="left" alt=""><![CDATA[
    HTTP/1.1 200 OK
    Content-Type: application/alto-tips+json
    Content-Length: 291

    {
        "tips-view-uri": "/tips/2718281828459",
        "tips-view-summary": {
          "updates-graph-summary": {
            "start-seq": 101,
            "end-seq": 106,
            "start-edge-rec" : {
              "seq-i": 0,
              "seq-j": 105
            }
          },
          "server-push": false
        }
    }
        ]]></artwork>
      </section> 

      <section anchor="tips-delete" numbered="true" toc="default">
        <name>Close Request</name>

        <t>An ALTO client can indicate it no longer desires to pull/receive updates 
        for a specific network resource by "deleting" the TIPS view using the returned 
        tips-view-uri and the HTTP DELETE method.  Whether or not the server
        actually deletes the TIPS view is implementation dependent. Likely,
        a server will remove the client from a dependency set associated with the TIPS view.  A server will not want to 
        delete a TIPS view if another client is using it.  The DELETE request looks like:
        </t>

        <artwork name="" type="" align="left" alt=""><![CDATA[
    DELETE /<tips-view-uri>
        ]]></artwork>

        <t>The response to a valid request MUST be 200 if success, and the corresponding 
            error code if there is any error.</t> 

        <t>If the connection between the client and TIPS provider is severed without a DELETE 
        request having been sent, the server MUST treat it as if the client had sent a DELETE request 
        because the TIPS view is, at least from the client view, per-session based.</t>

      </section>

    </section>

      <section anchor="metadata-directory" numbered="true" toc="default">
        <name>TIPS View Metadata Directory</name>

        <t>An ALTO client can read the metadata directory of the updates graph 
        to understand its full contents beyond the intial summary provided (perhaps 
        to calculate a new shortest path to the end of the graph after not having 
        fetched for a period of time).</t>

        <section anchor="dir-req" numbered="true" toc="default">
          <name>Request</name>

          <t>An ALTO client requests the updates graph's metadata directory 
        by sending an HTTP GET request with the media type 
        "application/alto-tipsgraph+json".  The GET request looks like:</t>

        <artwork name="" type="" align="left" alt=""><![CDATA[
    GET /<tips-view-uri>/ug 
        ]]></artwork>

        <t>An ALTO client can also read the metadata of an individual edge 
        in the updates graph.  The HTTP method is a GET, and looks like:</t>

        <artwork name="" type="" align="left" alt=""><![CDATA[
    GET /<tips-view-uri>/ug/meta/<i>/<j>
        ]]></artwork>

        </section>

        <section anchor="dir-resp" numbered="true" toc="default">
          <name>Response</name>
          <t>If the TIPS view is closed, the ALTO server MUST return an 
             error HTTP message with status code 404 (Not Found) and media type 
             "application/alto-error+json".</t>

          <t>The response from the server, if no error, is the UpdatesGraph object indicated as "application/alto-tipsgraph+json" media type:</t>

          <artwork name="" type="" align="left" alt=""><![CDATA[
    object {
      GraphDirMeta   meta;
      UpdatesGraph   updates-graph;
    } UpdatesDirectory : ResponseEntityBase;

    object {
      ResourceID     resource-id;
      Tag            tag;
    } GraphDirMeta

    object-map {
      StartSeq -> EndSeqUpdates;
    } UpdatesGraph;

    object-map {
      EndSeq -> UpdateItemMeta;
    } EndSeqUpdates;

    object {
      JSONString    media-type;
      JSONString    tag;
      JSONNumber    size;
    } UpdateItemMeta;

        ]]></artwork>

        <t>with the following fields:</t>
          <dl>
            <dt>meta: </dt>
            <dd>
              <t>Specifies the network resource-id TIPS view to which the directory corresponds
              and the version tag of the directory itself.</t>
            </dd>
            <dt>updates-graph: </dt>
            <dd>
              <t>Contains a map of edges in the updates graph (start-seq to end-seq).  Each 
              edge has a corresponding update-item-meta which includes the edge's 
              media type, resource version tag, and size of the content in kilobytes.</t>
            </dd>
          </dl>
       
      </section>

      <section anchor="dir-example" numbered="true" toc="default">
        <name>Example</name>

        <artwork name="" type="" align="left" alt=""><![CDATA[
   GET /tips/2718281828459/ug HTTP/1.1
   Host: alto.example.com
   Accept: application/alto-tipsgraph+json, application/alto-error+json
   Authorization: Basic Y2xpZW50MTpoZWxsb2FsdG8K


   HTTP/1.1 200 OK
   Content-Type: application/alto-tipsgraph+json
   Content-Length: 488

   {
      "meta": {
        "resource-id": "2718281828459"
        "tag": 125351264356
      },
      "updates-graph": {
        0: {
          101: {alto-costmap+json, 10978342, 1000000},
          103: {alto-costmap+json, 12340088, 1004000},
          105: {alto-costmap+json, 12356783, 1008033}
        },
        101: {
          102: {application/merge-patch+json, 12356643, 4040}
        },
        102: {
          103: {application/merge-patch+json, 12356644, 3000}
        },
        103: {
          104: {application/merge-patch+json, 12356645, 8000}
        },
        104: {
          105: {application/merge-patch+json, 12356646, 10000}
        },
        105: {
          106: {application/merge-patch+json, 12356647, 4040}
        }
      }
   }
        ]]></artwork>
      </section>

      <section anchor="refresh-directory" numbered="true" toc="default">
        <name>Refresh Directory</name>

        <t>An ALTO client can refresh the updates graph directory 
        without re-fetching the whole updates graph object. </t>

        <section anchor="ref-dir-req" numbered="true" toc="default">
          <name>Request</name>

          <t>An ALTO client requests the updates graph's metadata directory 
        by sending an HTTP GET request with the media type 
        "application/alto-tipsgraph+json".  The GET request looks like:</t>

        <artwork name="" type="" align="left" alt=""><![CDATA[
    POST /tips/2718281828459/ug HTTP/1.1
    Host: alto.example.com
    Accept: application/alto-tipsgraph+json, 
            application/merge-patch+json,
            application/alto-error+json
    Authorization: Basic Y2xpZW50MTpoZWxsb2FsdG8K
    Content-Type: application/alto-tipsparams+json
    Content-Length: 41

    {
      "tag": 125351264356
    }
        ]]></artwork>
      </section>

      <section anchor="ref-dir-resp" numbered="true" toc="default">
        <name>Response</name>

        <t>The server may return the whole directory or the incremental changes, 
        using merge-patch.  A patch response looks like:</t>

        <artwork name="" type="" align="left" alt=""><![CDATA[

    HTTP/1.1 200 OK
    Content-Type: application/merge-patch+json
    Content-Length: 200

    {
      "meta": {
        "tag": 543353364839
      },
      "updates-map": {
        0: {
          101: null,
          107: {...}
        },
        101: null,
        102: null 
      }
    }
        ]]></artwork>
          

        </section>

        
      </section>

      <section anchor="update-invariants" numbered="true" toc="default">
          <name>Server Updates Directory Invariants</name>
          <t>A server may change its updates graph (to compact, etc.), but it must satisfy the following invariants:</t>
        <ul>
          <li>Continuity: ns -&gt; ne, anything in between ns and ne also exists (implies ni -&gt; ni + 1 patch exists), 
          where ns is start-seq and ne is end-seq</li>
          <li>Feasibility: let n0 denote the smallest version in N (where N is the complete set of nodes in the updates graph), 
          the server can provide a snapshot of n0. In other words, there is always a direct link to ns</li>
          <li>"Right shift" only: if a server provides [n1, n2] at time t and [n1', n2'] at time t'. If t' &gt; t and get [n1', n2'], then n1' &gt;= n1 and n2' &gt;= n2.</li>
        </ul>
        <t>For example, using the example model in <xref target="basic-data-model" format="default"/>, assume at time 0, the server provides the valid set [101,
        102, 103, 104, 105, 106].  At time 1, both [103, 104, 105, 106] and [105, 106] are valid sets. However, [102, 103, 104, 105, 106]
        is not a valid set as there is no snapshot of the version at 102 and [104, 105, 106] is not a valid set as there is no snapshot of the version at 104.  
        Thus, there is a risk that the right content of the version at 102, in the first example, and 104, in the second example,
        cannot be obtained by a client that does not have the previous version at 101 or 103, respectively.</t>

      </section>
    </section>

    <section anchor="client-pull" numbered="true" toc="default">
      <name>TIPS Data Transfers - Client Pull</name>

      <t>TIPS allows an ALTO client to retrieve the content of
         an update item from the updates graph, with an update item 
         defined as the content (patch or snapshot) on an edge 
         in the updates graph. </t>

      <section anchor="pull-request" numbered="true" toc="default">
        <name>Request</name>

        <t>The client sends an HTTP GET request, where the media
        type of an update item resource MUST be the same as
        the "media-type" field of the update item on the specified edge 
        in the updates graph. </t>

        <t>For example, if the client wants to query the content of the first
           update item (0 -&gt; 101) whose media type is
           "application/alto-costmap+json", it must set the "Accept" header to
           "application/alto-costmap+json, application/alto-error+json" in the
           request.
        </t>

        <t>The GET request looks like</t>

        <artwork name="" type="" align="left" alt=""><![CDATA[
    GET /<tips-view-uri>/ug/<i>/<j>
        ]]></artwork>

        <t>For example, if the client wants to query the content of the first
           update item (0 -&gt; 101), it can send a request to
           "/tips/2718281828459/ug/0/101".
        </t>
      </section>

      <section anchor="urs-response" numbered="true" toc="default">
        <name>Response</name>

        <t>If the request is valid (ug/&lt;i&gt;/&lt;j&gt; exists), the response is encoded as a JSON object
           whose data format is indicated by the media type.
        </t>

        <t>It is possible that a client conducts proactive fetching of future updates, by long pulling updates 
        that have not been listed in the directory yet. For long-pull prefetch, the client must have
        indicated the media type which may appear. It is RECOMMENDED that the server allows for at 
        least the prefetch of &lt;end-seq&gt; -&gt; &lt;end-seq + 1&gt;</t>

        <t>Hence, the server processing logic SHOULD be:</t>
        <ul>
          <li>If ug/&lt;i&gt;/&lt;j&gt; exists: return content using encoding.</li>
          <li>Else if ug/&lt;i&gt;/&lt;j&gt; pre-fetch is acceptable: put request in a backlog queue.</li>
          <li>Else: return error.</li>
        </ul>

        <section anchor="server-errors" numbered="true" toc="default">
          <name>Server Processing "Error" Conditions</name>

          <t>It is RECOMMENDED that the server uses the following HTTP codes to 
          indicate errors, with the media type "application/alto-error+json",
          regarding update item requests. </t>

          <ul>
            <li>404 (Not Found): if the requested TIPS view does not exist or is closed.</li>
            <li>410 (Gone): if an update has a seq that is smaller than the start-seq.</li> 
            <li>415 (Unsupported Media Type): if the media type(s) accepted by the client 
            does not include the media type of the update chosen by the server.</li>
            <li>425 (Too Early): if the seq exceeds the server prefetch window</li>
            <li>429 (Too Many Requests): when the number of pending (long-pull) requests 
            exceeds server threshold. Server may indicate when to re-try the request in the 
            "Re-Try After" headers.</li>
          </ul>
        </section>
      </section>

      <section anchor="urs-example" numbered="true" toc="default">
        <name>Example</name>

        <t>Assume the client wants to get the contents of the update item on edge 0 to 101. The
           request is:</t>

        <artwork name="" type="" align="left" alt=""><![CDATA[
    GET /tips/2718281828459/ug/0/101 HTTP/1.1
    Host: alto.example.com
    Accept: application/alto-costmap+json, application/alto-error+json
        ]]></artwork>

        <t>And the response will be</t>

        <artwork name="" type="" align="left" alt=""><![CDATA[
    HTTP/1.1 200 OK
    Content-Type: application/alto-costmap+json
    Content-Length: 50

    { ... full replacement of my-routingcost-map ... }        
        ]]></artwork>
      </section>

    </section> <!-- End Client Pull -->

    <section anchor="server-push" numbered="true" toc="default">
      <name>TIPS Data Transfer - Server Push</name>

      <t>TIPS allows an ALTO client to receive an update item pushed by the ALTO server. </t>

      <t>If a client registers for server push, it should not request updates via pull to avoid receiving the same information twice,
      unless the client does not receive the expected updates (see <xref target="ops-clientproc" format="default"/>).</t> 

        <section anchor="manage-push" numbered="true" toc="default">
          <name>Manage Server Push</name>

          <t>A client starts to receive server push when it is added to the receiver set.
          A client can read the status of the push state and remove itself from the receiver set to stop server push.</t>

          <section anchor="push-start" numbered="true" toc="default">
            <name>Start Server Push</name>
              
            <t>A client can add itself explicitly to the receiver set or add itself to the receiver set when 
            requesting the TIPS view.</t> 

            <t>Explicit add: A client can explicitly add itself in the receiver set by using the HTTP PUT method with media type 
            "application/alto-tipspush+json", where the 
            client may optionally specify a starting edge (next-edge) from which it would like to receive updates:</t>
            <artwork name="" type="" align="left" alt=""><![CDATA[
    PUT /<tips-view-uri>/push  

    object {
      Boolean     server-push;
      [NextEdge    next-edge;]
    } PushState

    object {
      JSONNumber       seq-i;
      JSONNumber       seq-j;
    } NextEdge   
          ]]></artwork>

          <t>Short cut add: When requesting a TIPS view, an ALTO client can 
          start server push by setting the option "server-push" field to be true using the HTTP POST method 
          defined in <xref target="tips-createreq" format="default"/>.</t>

          <t>Example of a client requesting a TIPS view and starting server push:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    Client -> server request

    HEADERS
      - END_STREAM
      + END_HEADERS
        :method = POST
        :scheme = https
        :path = /tips
        host = alto.example.com
        accept = application/alto-error+json,
                      application/alto-tips+json
        content-type = application/alto-tips+json
        content-length = 69

    DATA
      - END_STREAM
      {
        "resource-id": "my-routingcost-map",
        ["server-push": true]
      }

    Server -> client response:

    HEADERS
      - END_STREAM
      + END_HEADERS
        :status = 200
        content-type = application/alto-tips+json
        content-length = 196
    
    DATA
      - END_STREAM
      {
        "tips-view-uri": "/tips/2718281828459",
        "tips-view-summary": {
          "updates-graph-summary": {
            "start-seq": 101,
            "end-seq": 106,
            "start-edge-rec" : {
              "seq-i": 0,
              "seq-j": 105
            }
          },
          "server-push": true
        }
      }
            
          ]]></artwork>
        </section>

        <section anchor="push-read" numbered="true" toc="default">
          <name>Read Push State</name>
          <t>A client can use the HTTP GET method, with accept header set to "application/alto-tipspush+json" 
          (defined in <xref target="push-start" format="default"/>) to check the status of server push. 
          Note that a server SHOULD send next-edge 
          to inform the client which item will be pushed next. </t>

          <artwork name="" type="" align="left" alt=""><![CDATA[
    GET /<tips-view-uri>/push     
          ]]></artwork>

          <t>Example:</t>

          <artwork name="" type="" align="left" alt=""><![CDATA[
    Client -> server request

    HEADERS
      - END_STREAM
      + END_HEADERS
        :method = GET
        :scheme = https
        :path = /tips/2718281828459/push
        host = alto.example.com
        accept = application/alto-error+json,
                      application/alto-tipspush+json

    Server -> client response:

    HEADERS
      - END_STREAM
      + END_HEADERS
        :status = 200
        content-type = application/alto-tipspush+json
        content-length = 519
    
    DATA
      - END_STREAM
      {
        "server-push": true;
        "next-edge": {
          "seq-i": 0,
          "seq-j": 105
        }
      } 
          ]]></artwork>

      </section>

      <section anchor="push-stop" numbered="true" toc="default">
        <name>Stop Push</name>

          <t>A client can stop receiving server push updates either explicitly or 
            implicitly.</t>

          <t>Explicit stop: A client stops push by using the HTTP PUT method to 
          /&lt;tips-view-uri&gt;/push, with content type 
          "application/alto-tipspush+json" and setting server-push to FALSE:</t>

          <t>Implicit stop: (1) TIPS view is connection ephemeral: the close of connection or 
          stream for the TIPS view deletes the TIPS view from the view of the client. (2) The client 
          sends a DELETE /&lt;tips-view-uri&gt; request, indicating it no longer is interested 
          in the resource, which also deletes the client from the push receiver set if present. </t>

          <t>Note that a client may choose to explicitly stop server push for a resource, but 
          may not delete the TIPS view so that it can switch seemlessly from server push to 
          client pull in the case that the server push frequency is undesirable, without having 
          to request a new TIPS view. </t>

          <t>Example of explicit stop:</t>

          <artwork name="" type="" align="left" alt=""><![CDATA[
    Client -> server request

    HEADERS
      - END_STREAM
      + END_HEADERS
        :method = PUT
        :scheme = https
        :path = /tips/2718281828459/push
        host = alto.example.com
        accept = application/alto-error+json
        content-type = application/alto-tipspush+json
        content-length = 69

    DATA
      - END_STREAM
      {
        "server-push": false
      }

    Server-> client response

    HEADERS
      - END_STREAM
      + END_HEADERS
        :status = 200
          ]]></artwork>

      </section>

      </section>
      <!-- receiver set -->

      <section anchor="altoh2push" numbered="true" toc="default">
        <name>Server Push of Incremental Updates</name>

        <section anchor="altoh2pushops" numbered="true" toc="default">
          <name>Server Push</name>

          <t>The objective of the server is to push the latest version to the client using 
          the lowest cost (sum of size) of the updates. Hence, it is recommended that the 
          server computes the push path using the following algorithm, upon each event computing a push:</t>
          <ul>
            <li>Compute client current version (n_c). During initialization, if the TIPS view request 
            has a tag, find that version; otherwise n_c = 0</li>
            <li>Compute the shortest path from current version to latest version, n_c, n1, ... n_e (latest version). Note that 
            the shortest path may not involve the tagged version and instead follow the edge from 0 to the latest snapshot.</li>
            <li>push /&lt;tips-view-uri>/ug/n_c/n1</li>
          </ul>

          <t>Note</t>
          <ul spacing="normal">
            <li>Initialization: the client MUST set SETTINGS_ENABLE_PUSH to be 
              consistent.  If the client specifically requests a starting edge to be pushed, the server 
              SHOULD start with that edge, even if it is not the shortest path.</li>
            <li>Push state: the server MUST maintain the last entry pushed to the client (and hence 
            per client, per connection state) and schedule next update push accordingly.</li>
            <li>Push management: The client MUST NOT cancel (RST_STREAM) a PUSH_PROMISE to avoid 
            complex server state management.</li>
          </ul>
        </section>

        <section anchor="altoh2pushexamples" numbered="true" toc="default">
          <name>Examples</name>

          <t>Using the example updates graph in <xref target="basic-data-model" format="default"/>, 
          a client can wait on the server for incremental push, where the server first sends PUSH_PROMISE: </t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    Server -> client PUSH_PROMISE in current stream:

    PUSH_PROMISE     
      - END_STREAM
        Promised Stream 4
        HEADER BLOCK
        :method = GET
        :scheme = https
        :path = /tips/2718281828459/ug/0/101
        host = alto.example.com
        accept = application/alto-error+json,
                      application/alto-costmap+json

    Server -> client content Stream 4:

    HEADERS
      + END_STREAM
      + END_HEADERS
        :status = 200
        content-type = application/alto-costmap+json
        content-length = 539
    
    DATA
      + END_STREAM
      {
        "meta" : {
          "dependent-vtags" : [{
              "resource-id": "my-network-map",
              "tag": "da65eca2eb7a10ce8b059740b0b2e3f8eb1d4785"
            }],
          "cost-type" : {
            "cost-mode"  : "numerical",
            "cost-metric": "routingcost"
          },
          "vtag": {
            "resource-id" : "my-routingcost-map",
            "tag" : "3ee2cb7e8d63d9fab71b9b34cbf764436315542e"
          }
        },
        "cost-map" : {
          "PID1": { "PID1": 1,  "PID2": 5,  "PID3": 10 },
          "PID2": { "PID1": 5,  "PID2": 1,  "PID3": 15 },
          "PID3": { "PID1": 20, "PID2": 15  }
        }
    }

    Server -> client PUSH_PROMISE in current stream:

    PUSH_PROMISE     
      - END_STREAM
        Promised Stream 6
        HEADER BLOCK
        :method = GET
        :scheme = https
        :path = /tips/2718281828459/ug/101/102
        host = alto.example.com
        accept = application/alto-error+json,
                      application/merge-patch+json

    Server -> client content Stream 6

    HEADERS
      + END_STREAM
      + END_HEADERS
        :status = 200
        content-type = application/merge-patch+json
        content-length = 7
    
    DATA
      + END_STREAM
      {
        "meta": {
            "vtag": {
              "tag": "c0ce023b8678a7b9ec00324673b98e54656d1f6d"
            }
        },
        "cost-map": {
          "PID1": {
            "PID2": 9
          },
          "PID3": {
            "PID1": null,
            "PID3": 1
          }
        }
      }
            ]]></artwork>
        </section>
      </section>

      <section anchor="altoh2streams" numbered="true" toc="default">
        <name>Server Push Stream Management</name>

        <section anchor="altoh2streampush" numbered="true" toc="default">
          <name>Server -&gt; Client [PUSH_PROMISE for updates graph on Stream SID_tq]</name>
          <t>The server push MUST satisfy the following requirements:</t>
          <ul spacing="normal">
            <li>PUSH_PROMISE MUST be sent in stream SID_tq to serialize and allow the client to know the push order;</li>
            <li>Each PUSH_PROMISE chooses a new server-selected stream ID, and the stream is closed after push.</li>
          </ul>
        </section>

      </section>
    </section>

    <section anchor="ops" numbered="true" toc="default">
      <name>Operation and Processing Considerations</name>

      <section anchor="ops-loadbalancing" numbered="true" toc="default">
         <name>Considerations for Load Balancing</name>
         <t>TODO</t>
      </section>

      <section anchor="ops-chooseupdates" numbered="true" toc="default">
         <name>Considerations for Choosing Updates</name>

         <t>TIPS should be cognizant of the effects of its update schedule, which
            includes both the choice of timing (i.e., when/what to trigger an 
            update on the updates graph) and the choice of message format
            (i.e., given an update, send a full replacement or an incremental
            change).  In particular, the update schedule can have effects on both
            the overhead and the freshness of information.  To minimize overhead,
            TIPS may choose to batch a sequence of updates for resources
            that frequently change by cumulative updates or a full
            replacement after a while.  TIPS should be
            cognizant that batching reduces the freshness of information.  The
            server should also consider the effect of such delays on client
            behaviors.
          </t>

          <t>For incremental updates, this design allows both JSON patch and JSON
             merge patch for incremental changes.  JSON merge patch is clearly
             superior to JSON patch for describing incremental changes to cost
             maps, endpoint costs, and endpoint properties.  For these data
             structures, JSON merge patch is more space efficient, as well as
             simpler to apply.  There is no advantage allowing a server to use
            JSON patch for those resources.</t>

           <t>The case is not as clear for incremental changes to network maps.</t>

          <t>First, consider small changes, such as moving a prefix from one PID
   to another.  JSON patch could encode that as a simple insertion and
   deletion, while JSON merge patch would have to replace the entire
   array of prefixes for both PIDs.  On the other hand, to process a
   JSON patch update, the ALTO client would have to retain the indexes
   of the prefixes for each PID.  Logically, the prefixes in a PID are
   an unordered set, not an array; aside from handling updates, a client
   has no need to retain the array indexes of the prefixes.  Hence, to
   take advantage of JSON patch for network maps, ALTO clients would
   have to retain additional, otherwise unnecessary, data.</t>

          <t>Second, consider more involved changes, such as removing half of the
   prefixes from a PID.  JSON merge patch would send a new array for
   that PID, while JSON patch would have to send a list of remove
   operations and delete the prefix one by one.</t>

          <t>Therefore, each TIPS may decide on its own whether to
   use JSON merge patch or JSON patch according to the changes in
   network maps.</t>
         </section>

        <section anchor="ops-scheduling" numbered="true" toc="default">
          <name>Considerations for Cross-Resource Dependency Scheduling</name>

          <t>Dependent ALTO resources result in cross-resource dependenies in TIPS. 
          Consider the following pair of resources, where my-cost-map is 
          dependent on my-network-map:</t>

          <figure anchor="dependency-model">
            <name>Example Dependency Model</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
                       +---+   +---+   +---+   +---+   +---+
  my-network-map (N)   | 0 |-->|101|-->|102|-->|103|-->|104|
                       +---+   +---+   +---+   +---+   +---+
                                 |   \       \
                                 |    \       \
                       +---+   +---+   +---+   +---+   +---+
  my-cost-map (C)      | 0 |-->|101|-->|102|-->|103|-->|104|
                       +---+   +---+   +---+   +---+   +---+                                     
                        |_______________________|
            ]]></artwork>
          </figure>

          <t>In pull-mode, a client can decide the order in which to receive the updates.</t>

          <t>In push-mode, the server must decide. Pushing order may affect how fast the client 
          can build a consistent view and how long the client needs to buffer the update. </t>
          <ul>
            <li>Example 1: The server pushes N101, N102, N103, C101, C102 in that order. The client either gets no consistent 
            view of the resources or it has to buffer N2 and N3 </li>
            <li>Example 2: The server pushes C1, C2, C3, N1. The client either gets no consistent view or 
            it has to buffer C3. </li>
          </ul>

          <t>Therefore, the server is RECOMMENDED to push updates in the ascending order of the smallest dependent tag, 
          e.g., {C1, C2, N1} before {C3, N2}</t>
          
        </section>

        <section anchor="ops-clientproc" numbered="true" toc="default">
          <name>Considerations for Client Processing Updates</name>

          <t>In general, when an ALTO client receives a full replacement for a
   resource, the ALTO client should replace the current version with the
   new version.  When an ALTO client receives an incremental change for
   a resource, the ALTO client should apply those patches to the current
   version of the resource.</t>

          <t>However, because resources can depend on other resources (e.g., cost
   maps depend on network maps), an ALTO client MUST NOT use a dependent
   resource if the resource on which it depends has changed.  There are
   at least two ways an ALTO client can do that.  The following
   paragraphs illustrate these techniques by referring to network and
   cost map messages, although these techniques apply to any dependent
   resources.</t>

          <t>Note that when a network map changes, the server SHOULD
   send the network map update message before sending the updates for
   the dependent cost maps.</t>

          <t>One approach is for the ALTO client to save the network map update
   message in a buffer and continue to use the previous network map and
   the associated cost maps until the ALTO client receives the update
   messages for all dependent cost maps.  The ALTO client then applies
   all network and cost map updates atomically.</t>

          <t>Alternatively, the ALTO client MAY update the network map
   immediately.  In this case, the cost maps using the network map
   become invalid because they are inconsistent with the current network
   map; hence, the ALTO client MUST mark each such dependent cost map as
   temporarily invalid and MUST NOT use each such cost map until the
   ALTO client receives a cost map update indicating that it is
   based on the new network map version tag.</t>

          <t>When implementing server push, the server SHOULD send updates for dependent resource 
   (i.e., the cost maps in the preceding example) in a timely fashion.
   However, if the ALTO client does not receive the expected updates, a
   simple recovery method is that the ALTO client uses client pull to
   request the missing update.  The ALTO client MAY retain the
   version tag of the last version of any tagged resources and search
   those version tags when identifying the new updates to pull. 
   Although not as efficient as possible, this recovery method is simple
   and reliable.</t>
        </section>

        <section anchor="ops-filtered" numbered="true" toc="default">
          <name>Considerations for Updates to Filtered Cost Maps</name>

          <t>If TIPS provides updates to a Filtered Cost Map that
   allows constraint tests, then an ALTO client MAY request updates to a
   Filtered Cost Map request with a constraint test.  In this case, when
   a cost changes, the updates graph MUST have an update if the
   new value satisfies the test.  If the new value does not, whether 
   there is an update depends on whether the previous
   value satisfied the test.  If it did not, the updates graph
   SHOULD NOT have an update.  But if the previous
   value did, then the updates graph MUST add an update with a
   "null" value to inform the ALTO client that this cost no longer
   satisfies the criteria.</t>

          <t>TIPS can avoid having to handle such a complicated
   behavior by offering TIPS only for Filtered Cost Maps that
   do not allow constraint tests.</t>
         </section>

         <section anchor="ops-ordinal" numbered="true" toc="default">
          <name>Considerations for Updates to Ordinal Mode Costs</name>

           <t>For an ordinal mode cost map, a change to a single cost point may
   require updating many other costs.  As an extreme example, suppose
   the lowest cost changes to the highest cost.  For a numerical mode
   cost map, only that one cost changes.  But for an ordinal mode cost
   map, every cost might change.  While this document allows TIPS to 
   offer incremental updates for ordinal mode cost
   maps, TIPS implementors should be aware that
   incremental updates for ordinal costs are more complicated than for
   numerical costs, and ALTO clients should be aware that small changes
   may result in large updates.</t>

            <t>A TIPS can avoid this complication by only offering
   full replacements as updates in the updates graph for ordinal cost maps.</t>
        </section>

    </section> <!-- OPS -->


    <section anchor="sec-sec" numbered="true" toc="default">
       <name>Security Considerations</name>

       <t>The security considerations (Section 15 of <xref target="RFC7285" format="default"/>) of the base
   protocol fully apply to this extension.  For example, the same
   authenticity and integrity considerations (Section 15.1 of <xref target="RFC7285" format="default"/>)
   still fully apply; the same considerations for the privacy of ALTO
   users (Section 15.4 of <xref target="RFC7285" format="default"/>) also still fully apply.</t>

       <t>The additional services (addition of update read service and update
   push service) provided by this extension extend the attack surface
   described in Section 15.1.1 of <xref target="RFC7285" format="default"/>.  Below, we discuss the
   additional risks and their remedies.</t>

       <section anchor="sec-ddos" numbered="true" toc="default">
          <name>TIPS: Denial-of-Service Attacks</name>

          <t>Allowing TIPS views enables a new class of
   Denial-of-Service attacks. In particular, For the TIPS server, 
   an ALTO client might create an unreasonable number of TIPS views.</t>

          <t>To avoid these attacks on the TIPS server, the server SHOULD
   choose to limit the number of active views and reject new requests
   when that threshold is reached.  TIPS allows 
   predictive fetching and the server SHOULD also choose to limit the 
   number of pending requests.  In these cases, the server
   SHOULD return the HTTP status "429 Too many requests".</t>

          <t>It is important to note that the preceding approaches are not the
   only possibilities.  For example, it may be possible for TIPS to 
   use somewhat more clever logic involving IP reputation, rate-limiting, 
   and compartmentalization of the overall threshold into smaller thresholds 
   that apply to subsets of potential clients.</t>
       </section>

       <section anchor="sec-overload" numbered="true" toc="default">
          <name>ALTO Client: Update Overloading or Instability</name>

          <t>The availability of continuous updates, when the client indicates 
   receiving server push, can also cause overload for an
   ALTO client, in particular, an ALTO client with limited processing
   capabilities.  The current design does not include any flow control
   mechanisms for the client to reduce the update rates from the server.
   Under overloading, the client MAY choose to remove the information
   resources with high update rates.</t>

           <t>Also, under overloading, the client may no longer be able to detect
   whether information is still fresh or has become stale.  In such a
   case, the client should be careful in how it uses the information to
   avoid stability or efficiency issues.</t>
      </section>

      <section anchor="sec-spoof" numbered="true" toc="default">
          <name>Spoofed URI</name>

          <t>An outside party that can read the TIPS response or that can
   observe TIPS requests can obtain the TIPS view URI and use
   that to send fraudulent "DELETE" requests, thus disabling the service
   for the valid ALTO client.  This can be avoided by encrypting the
   requests and responses (see Section 15 of
   <xref target="RFC7285" format="default"/>).  </t>
         </section>

    </section>


    <section anchor="ianaconsider" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>IANA is requested to register the following media type under ALTO registry as defined in <xref target="RFC7285" format="default"/>:
      </t>
      <ul spacing="normal">
        <li>application/alto-tips+json: as described in <xref target="tips-createresp" format="default"/>;</li>
        <li>application/alto-tipsparams+json: as described in <xref target="tips-createreq" format="default"/>;</li>
        <li>application/alto-tipsgraph+json: as described in <xref target="dir-resp" format="default"/></li>
        <li>application/alto-tipspush+json: as described in <xref target="push-start" format="default"/></li>
      </ul>
      <section numbered="true" toc="default">
        <name>application/alto-tips+json Media Type</name>
        <dl>
          <dt>Type name:</dt>
          <dd>application</dd>
          <dt>Subtype name:</dt>
          <dd>alto-tips+json</dd>
          <dt>Required parameters:</dt>
          <dd>N/A</dd>
          <dt>Optional parameters:</dt>
          <dd>N/A</dd>
          <dt>Encoding considerations:</dt>
          <dd>Encoding considerations are identical to those specified for the
          "application/json" media type. See <xref target="RFC8259" format="default"/>.
          </dd>
          <dt>Security considerations:</dt>
          <dd>Security considerations relating to the generation and consumption
          of ALTO Protocol messages are discussed in Section 10 of
          <xref target="RFC8895"/> and Section 15 of <xref target="RFC7285"/>.
          </dd>
          <dt>Interoperability considerations:</dt>
          <dd>This document specifies format of conforming messages and the
          interpretation thereof.
          </dd>
          <dt>Published specification:</dt>
          <dd><xref target="tips-createresp"/> of this document.</dd>
          <dt>Applications that use this media type:</dt>
          <dd>ALTO servers and ALTO clients either stand alone or are embedded
          within other applications.</dd>
          <dt>Fragment identifier considerations:</dt>
          <dd>N/A</dd>
          <dt>Additional information:</dt>
          <dd>
            <t><br/></t>
            <dl>
              <dt>Deprecated alias names for this type:</dt>
              <dd>N/A</dd>
              <dt>Magic number(s):</dt>
              <dd>N/A</dd>
              <dt>File extension(s):</dt>
              <dd>This document uses the media type to refer to protocol messages
              and thus does not require a file extension.</dd>
              <dt>Macintosh file type code(s):</dt>
              <dd>N/A</dd>
            </dl>
          </dd>
          <dt>Person and email address to contact for further information:</dt>
          <dd>See Authors' Addresses section.</dd>
          <dt>Intended usage:</dt>
          <dd>COMMON</dd>
          <dt>Restrictions on usage:</dt>
          <dd>N/A</dd>
          <dt>Author:</dt>
          <dd>See Authors' Addresses section.</dd>
          <dt>Change controller:</dt>
          <dd>Internet Engineering Task Force (mailto:iesg@ietf.org).</dd>
        </dl>
      </section>
      <section numbered="true" toc="default">
        <name>application/alto-tipsparams+json Media Type</name>
        <dl>
          <dt>Type name:</dt>
          <dd>application</dd>
          <dt>Subtype name:</dt>
          <dd>alto-tipsparams+json</dd>
          <dt>Required parameters:</dt>
          <dd>N/A</dd>
          <dt>Optional parameters:</dt>
          <dd>N/A</dd>
          <dt>Encoding considerations:</dt>
          <dd>Encoding considerations are identical to those specified for the
          "application/json" media type. See <xref target="RFC8259" format="default"/>.
          </dd>
          <dt>Security considerations:</dt>
          <dd>Security considerations relating to the generation and consumption
          of ALTO Protocol messages are discussed in Section 10 of
          <xref target="RFC8895"/> and Section 15 of <xref target="RFC7285"/>.
          </dd>
          <dt>Interoperability considerations:</dt>
          <dd>This document specifies format of conforming messages and the
          interpretation thereof.
          </dd>
          <dt>Published specification:</dt>
          <dd><xref target="tips-createreq"/> of this document.</dd>
          <dt>Applications that use this media type:</dt>
          <dd>ALTO servers and ALTO clients either stand alone or are embedded
          within other applications.</dd>
          <dt>Fragment identifier considerations:</dt>
          <dd>N/A</dd>
          <dt>Additional information:</dt>
          <dd>
            <t><br/></t>
            <dl>
              <dt>Deprecated alias names for this type:</dt>
              <dd>N/A</dd>
              <dt>Magic number(s):</dt>
              <dd>N/A</dd>
              <dt>File extension(s):</dt>
              <dd>This document uses the media type to refer to protocol messages
              and thus does not require a file extension.</dd>
              <dt>Macintosh file type code(s):</dt>
              <dd>N/A</dd>
            </dl>
          </dd>
          <dt>Person and email address to contact for further information:</dt>
          <dd>See Authors' Addresses section.</dd>
          <dt>Intended usage:</dt>
          <dd>COMMON</dd>
          <dt>Restrictions on usage:</dt>
          <dd>N/A</dd>
          <dt>Author:</dt>
          <dd>See Authors' Addresses section.</dd>
          <dt>Change controller:</dt>
          <dd>Internet Engineering Task Force (mailto:iesg@ietf.org).</dd>
        </dl>
      </section>
      <section numbered="true" toc="default">
        <name>application/alto-tipsgraph+json Media Type</name>
        <dl>
          <dt>Type name:</dt>
          <dd>application</dd>
          <dt>Subtype name:</dt>
          <dd>alto-tipsgraph+json</dd>
          <dt>Required parameters:</dt>
          <dd>N/A</dd>
          <dt>Optional parameters:</dt>
          <dd>N/A</dd>
          <dt>Encoding considerations:</dt>
          <dd>Encoding considerations are identical to those specified for the
          "application/json" media type. See <xref target="RFC8259" format="default"/>.
          </dd>
          <dt>Security considerations:</dt>
          <dd>Security considerations relating to the generation and consumption
          of ALTO Protocol messages are discussed in Section 10 of
          <xref target="RFC8895"/> and Section 15 of <xref target="RFC7285"/>.
          </dd>
          <dt>Interoperability considerations:</dt>
          <dd>This document specifies format of conforming messages and the
          interpretation thereof.
          </dd>
          <dt>Published specification:</dt>
          <dd><xref target="dir-resp"/> of this document.</dd>
          <dt>Applications that use this media type:</dt>
          <dd>ALTO servers and ALTO clients either stand alone or are embedded
          within other applications.</dd>
          <dt>Fragment identifier considerations:</dt>
          <dd>N/A</dd>
          <dt>Additional information:</dt>
          <dd>
            <t><br/></t>
            <dl>
              <dt>Deprecated alias names for this type:</dt>
              <dd>N/A</dd>
              <dt>Magic number(s):</dt>
              <dd>N/A</dd>
              <dt>File extension(s):</dt>
              <dd>This document uses the media type to refer to protocol messages
              and thus does not require a file extension.</dd>
              <dt>Macintosh file type code(s):</dt>
              <dd>N/A</dd>
            </dl>
          </dd>
          <dt>Person and email address to contact for further information:</dt>
          <dd>See Authors' Addresses section.</dd>
          <dt>Intended usage:</dt>
          <dd>COMMON</dd>
          <dt>Restrictions on usage:</dt>
          <dd>N/A</dd>
          <dt>Author:</dt>
          <dd>See Authors' Addresses section.</dd>
          <dt>Change controller:</dt>
          <dd>Internet Engineering Task Force (mailto:iesg@ietf.org).</dd>
        </dl>
      </section>
      <section numbered="true" toc="default">
        <name>application/alto-tipspush+json Media Type</name>
        <dl>
          <dt>Type name:</dt>
          <dd>application</dd>
          <dt>Subtype name:</dt>
          <dd>alto-tipspush+json</dd>
          <dt>Required parameters:</dt>
          <dd>N/A</dd>
          <dt>Optional parameters:</dt>
          <dd>N/A</dd>
          <dt>Encoding considerations:</dt>
          <dd>Encoding considerations are identical to those specified for the
          "application/json" media type. See <xref target="RFC8259" format="default"/>.
          </dd>
          <dt>Security considerations:</dt>
          <dd>Security considerations relating to the generation and consumption
          of ALTO Protocol messages are discussed in Section 10 of
          <xref target="RFC8895"/> and Section 15 of <xref target="RFC7285"/>.
          </dd>
          <dt>Interoperability considerations:</dt>
          <dd>This document specifies format of conforming messages and the
          interpretation thereof.
          </dd>
          <dt>Published specification:</dt>
          <dd><xref target="push-start"/> of this document.</dd>
          <dt>Applications that use this media type:</dt>
          <dd>ALTO servers and ALTO clients either stand alone or are embedded
          within other applications.</dd>
          <dt>Fragment identifier considerations:</dt>
          <dd>N/A</dd>
          <dt>Additional information:</dt>
          <dd>
            <t><br/></t>
            <dl>
              <dt>Deprecated alias names for this type:</dt>
              <dd>N/A</dd>
              <dt>Magic number(s):</dt>
              <dd>N/A</dd>
              <dt>File extension(s):</dt>
              <dd>This document uses the media type to refer to protocol messages
              and thus does not require a file extension.</dd>
              <dt>Macintosh file type code(s):</dt>
              <dd>N/A</dd>
            </dl>
          </dd>
          <dt>Person and email address to contact for further information:</dt>
          <dd>See Authors' Addresses section.</dd>
          <dt>Intended usage:</dt>
          <dd>COMMON</dd>
          <dt>Restrictions on usage:</dt>
          <dd>N/A</dd>
          <dt>Author:</dt>
          <dd>See Authors' Addresses section.</dd>
          <dt>Change controller:</dt>
          <dd>Internet Engineering Task Force (mailto:iesg@ietf.org).</dd>
        </dl>
      </section>
    </section>

    <section numbered="true" toc="default">
      <name>Acknowledgments</name>
      <t>The authors of this document would also like to thank Adrian Farrel, Qin Wu, 
      Jordi Ros Giralt, and the many others who reviewed and commented on previous
      drafts of this document.</t>
    </section>
  </middle>

  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <!-- requirements words -->
    <reference anchor="RFC7285" target="https://www.rfc-editor.org/info/rfc7285" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7285.xml">
          <front>
            <title>Application-Layer Traffic Optimization (ALTO) Protocol</title>
            <author initials="R." surname="Alimi" fullname="R. Alimi" role="editor">
              <organization/>
            </author>
            <author initials="R." surname="Penno" fullname="R. Penno" role="editor">
              <organization/>
            </author>
            <author initials="Y." surname="Yang" fullname="Y. Yang" role="editor">
              <organization/>
            </author>
            <author initials="S." surname="Kiesel" fullname="S. Kiesel">
              <organization/>
            </author>
            <author initials="S." surname="Previdi" fullname="S. Previdi">
              <organization/>
            </author>
            <author initials="W." surname="Roome" fullname="W. Roome">
              <organization/>
            </author>
            <author initials="S." surname="Shalunov" fullname="S. Shalunov">
              <organization/>
            </author>
            <author initials="R." surname="Woundy" fullname="R. Woundy">
              <organization/>
            </author>
            <date year="2014" month="September"/>
            <abstract>
              <t>Applications using the Internet already have access to some topology information of Internet Service Provider (ISP) networks.  For example, views to Internet routing tables at Looking Glass servers are available and can be practically downloaded to many network application clients.  What is missing is knowledge of the underlying network topologies from the point of view of ISPs.  In other words, what an ISP prefers in terms of traffic optimization -- and a way to distribute it.</t>
              <t>The Application-Layer Traffic Optimization (ALTO) services defined in this document provide network information (e.g., basic network location structure and preferences of network paths) with the goal of modifying network resource consumption patterns while maintaining or improving application performance.  The basic information of ALTO is based on abstract maps of a network.  These maps provide a simplified view, yet enough information about a network for applications to effectively utilize them.  Additional services are built on top of the maps.</t>
              <t>This document describes a protocol implementing the ALTO services. Although the ALTO services would primarily be provided by ISPs, other entities, such as content service providers, could also provide ALTO services.  Applications that could use the ALTO services are those that have a choice to which end points to connect.  Examples of such applications are peer-to-peer (P2P) and content delivery networks.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7285"/>
          <seriesInfo name="DOI" value="10.17487/RFC7285"/>
        </reference>
        <!-- alto base -->
        <reference anchor="RFC8259" target="https://www.rfc-editor.org/info/rfc8259">
          <front>
            <title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
            <author fullname="T. Bray" initials="T." role="editor" surname="Bray"/>
            <date month="December" year="2017"/>
            <abstract>
              <t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format. It was derived from the ECMAScript Programming Language Standard. JSON defines a small set of formatting rules for the portable representation of structured data.</t>
              <t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="90"/>
          <seriesInfo name="RFC" value="8259"/>
          <seriesInfo name="DOI" value="10.17487/RFC8259"/>
          <format target="https://www.rfc-editor.org/info/rfc8259" type="TXT"/>
        </reference>
    <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <!-- requirements words -->
    <reference anchor="RFC8895" target="https://www.rfc-editor.org/info/rfc8895" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8895.xml">
          <front>
            <title>Application-Layer Traffic Optimization (ALTO) Incremental Updates Using Server-Sent Events (SSE)</title>
            <author initials="W." surname="Roome" fullname="W. Roome">
              <organization/>
            </author>
            <author initials="Y." surname="Yang" fullname="Y. Yang">
              <organization/>
            </author>
            <date year="2020" month="November"/>
            <abstract>
              <t>The Application-Layer Traffic Optimization (ALTO) protocol (RFC 7285) provides network-related information, called network information resources, to client applications so that clients can make informed decisions in utilizing network resources. This document presents a mechanism to allow an ALTO server to push updates to ALTO clients to achieve two benefits: (1) updates can be incremental, in that if only a small section of an information resource changes, the ALTO server can send just the changes and (2) updates can be immediate, in that the ALTO server can send updates as soon as they are available.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8895"/>
          <seriesInfo name="DOI" value="10.17487/RFC8895"/>
        </reference>
        <!-- ALTO SSE -->
        <reference anchor="RFC9112" target="https://www.rfc-editor.org/info/rfc9112" quoteTitle="true" derivedAnchor="HTTP/1.1">
          <front>
            <title>HTTP/1.1</title>
            <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
              <organization showOnFrontPage="true">Adobe</organization>
            </author>
            <author fullname="Mark Nottingham" initials="M." role="editor" surname="Nottingham">
              <organization showOnFrontPage="true">Fastly</organization>
            </author>
            <author fullname="Julian Reschke" initials="J." role="editor" surname="Reschke">
              <organization showOnFrontPage="true">greenbytes</organization>
            </author>
            <date month="June" year="2022"/>
          </front>
          <seriesInfo name="STD" value="99"/>
          <seriesInfo name="RFC" value="9112"/>
          <seriesInfo name="DOI" value="10.17487/RFC9112"/>
        </reference>
        <!-- HTTP/1.1 -->
        <reference anchor="RFC9113">
          <front>
            <title>HTTP/2</title>
            <author fullname="M. Thomson" initials="M." role="editor" surname="Thomson">
              <organization/>
            </author>
            <author fullname="C. Benfield" initials="C." role="editor" surname="Benfield">
              <organization/>
            </author>
            <date month="June" year="2022"/>
            <abstract>
              <t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced latency by introducing field compression and allowing multiple concurrent exchanges on the same connection.</t>
              <t>This document obsoletes RFCs 7540 and 8740.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9113"/>
          <seriesInfo name="DOI" value="10.17487/RFC9113"/>
        </reference>
        <!-- HTTP/2 -->
      <reference anchor="RFC9114" target="https://www.rfc-editor.org/info/rfc9114" quoteTitle="true" derivedAnchor="RFC9114">
          <front>
            <title>HTTP/3</title>
            <author fullname="M. Bishop" initials="M." role="editor" surname="Bishop"/>
            <date month="June" year="2022"/>
            <abstract>
              <t indent="0">The QUIC transport protocol has several features that are desirable in a transport for HTTP, such as stream multiplexing, per-stream flow control, and low-latency connection establishment.  This document describes a mapping of HTTP semantics over QUIC.  This document also identifies HTTP/2 features that are subsumed by QUIC and describes how HTTP/2 extensions can be ported to HTTP/3.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9114"/>
          <seriesInfo name="DOI" value="10.17487/RFC9114"/>
          <format target="https://www.rfc-editor.org/info/rfc9114" type="TXT"/>
        </reference>
        <!-- HTTP/3 -->
      </references>
      <references>
        <name>Informative References</name>

          <reference anchor="draft-schott-alto-new-transport-push" target="https://datatracker.ietf.org/doc/draft-schott-alto-new-transport-push/">
          <front>
            <title>ALTO New Transport: Server Push</title>
            <author initials="R." surname="Schott" fullname="R. Schott">
              <organization/>
            </author>
            <author initials="Y." surname="Yang" fullname="Y. Yang">
              <organization/>
            </author>
            <date year="2022" month="October"/>
          </front>
          <seriesInfo name="Internet Draft" value="ID"/>
        </reference>

        <reference anchor="RFC7971" target="https://www.rfc-editor.org/info/rfc7971" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7971.xml">
          <front>
            <title>Application-Layer Traffic Optimization (ALTO) Deployment Considerations</title>
            <author initials="M." surname="Stiemerling" fullname="M. Stiemerling">
              <organization/>
            </author>
            <author initials="S." surname="Kiesel" fullname="S. Kiesel">
              <organization/>
            </author>
            <author initials="M." surname="Scharf" fullname="M. Scharf">
              <organization/>
            </author>
            <author initials="H." surname="Seidel" fullname="H. Seidel">
              <organization/>
            </author>
            <author initials="S." surname="Previdi" fullname="S. Previdi">
              <organization/>
            </author>
            <date year="2016" month="October"/>
            <abstract>
              <t>Many Internet applications are used to access resources such as pieces of information or server processes that are available in several equivalent replicas on different hosts.  This includes, but is not limited to, peer-to-peer file sharing applications.  The goal of Application-Layer Traffic Optimization (ALTO) is to provide guidance to applications that have to select one or several hosts from a set of candidates capable of providing a desired resource. This memo discusses deployment-related issues of ALTO.  It addresses different use cases of ALTO such as peer-to-peer file sharing and Content Delivery Networks (CDNs) and presents corresponding examples. The document also includes recommendations for network administrators and application designers planning to deploy ALTO, such as recommendations on how to generate ALTO map information.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7971"/>
          <seriesInfo name="DOI" value="10.17487/RFC7971"/>
        </reference>
        <!-- requirements -->
      </references>
    </references>
  </back>
</rfc>
