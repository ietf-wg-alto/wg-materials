<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<!-- edited with XMLSPY v5 rel. 3 U (http://www.xmlspy.com)
     by Daniel M Kohn (private) -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" docName="draft-ietf-alto-new-transport-03" ipr="trust200902" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" symRefs="true" sortRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.12.10 -->
  <?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

  <front>
    <title abbrev="ALTO/H2">ALTO New Transport: ALTO Transport Information Structures</title>
    <seriesInfo name="Internet-Draft" value="draft-ietf-alto-new-transport-02"/>
    <author fullname="Roland Schott" initials="R." surname="Schott">
      <organization>Deutsche Telekom</organization>
      <address>
        <postal>
          <street>Heinrich-Hertz-Strasse 3-7</street>
          <city>64295 Darmstadt</city>
          <country>Germany</country>
        </postal>
        <email>Roland.Schott@telekom.de</email>
      </address>
    </author>
    <author fullname="Y. Richard Yang" initials="Y." surname="Yang">
      <organization>Yale University</organization>
      <address>
        <postal>
          <street>51 Prospect St</street>
          <city>New Haven</city>
          <region>CT</region>
          <code>06520</code>
          <country>USA</country>
        </postal>
        <email>yry@cs.yale.edu</email>
      </address>
    </author>
    <author fullname="Kai Gao" initials="K." surname="Gao">
      <organization>Sichuan University</organization>
      <address>
        <postal>
          <street/>
          <city>Chengdu</city>
          <code>201804</code>
          <country>China</country>
        </postal>
        <email>kgao@scu.edu.cn</email>
      </address>
    </author>
    <author fullname="Jingxuan Jensen Zhang" initials="J." surname="Zhang">
      <organization>Tongji University</organization>
      <address>
        <postal>
          <street>4800 Cao'An Hwy</street>
          <city>Shanghai</city>
          <code>201804</code>
          <country>China</country>
        </postal>
        <email>jingxuan.n.zhang@gmail.com</email>
      </address>
    </author>
    <date day="21" month="October" year="2022"/>
    <area>TSV Area</area>
    <workgroup>ALTO Working Group</workgroup>
    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>Application-Layer Traffic Optimization, HTTP/2, SSE, Message Queue</keyword>
    <abstract>
      <t>The ALTO base protocol [RFC7285] defines both the ALTO information resources and their transport from the server to the client. Using HTTP/1.x as the transport protocol, the  ALTO transport in the base protocol includes the limitations of HTTP/1.x. ALTO/SSE [RFC8895] defines a new transport design addressing some of the limitations, but is still based on HTTP/1.x. This document introduces ALTO new transport, which introduces ALTO transport information structures (TIS) at an ALTO server. The introduction of ALTO TIS allows at least two types of efficient transport using HTTP: (1) HTTP/2/3 independent client (long) pull allowed by non-blocking, newer HTTP, and (2) HTTP/2 specific server push. This document defines ALTO TIS and the first design. A companion document 
        <xref target="draft-schott-alto-new-transport-push" format="default"/> defines server-push ALTO transport based on ALTO TIS.
      </t>
    </abstract>
    <note>
      <name>Requirements Language</name>
      <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
          "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY",
          and "OPTIONAL" in this document are to be interpreted as described
          in BCP 14 <xref target="RFC2119" format="default"/><xref target="RFC8174" format="default"/> when,
          and only when, they appear in all capitals, as shown here.
      </t>
    </note>
  </front>
  <middle>
    <section anchor="intro" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Application-Layer Traffic Optimization (ALTO) provides a means for network applications 
      to obtain network status information. The ALTO base protocol <xref target="RFC7285" format="default"/> is based on the sequential request and response model of HTTP/1.1 <xref target="RFC7230" format="default"/>. Hence, the base protocol cannot support well the use cases where an ALTO client may need to efficiently monitor the changes to a set of network information resources. If the client opens a single HTTP connection, the request for one resource may block the request for the next resource. </t>

      <t>To address the issue using a protocol that is still based on the HTTP/1.1 transport model, the ALTO Working Group introduces ALTO/SSE (ALTO Incremental Update based on Server-Sent-Event) 
      <xref target="RFC8895" format="default"/>, so that an ALTO client can manage (i.e., add and remove) a set of 
      requests maintained at an ALTO server, and the server can continuously, concurrently, and 
      incrementally push updates whenever a monitored network information resource changes. 
      Figure 1 shows the architecture and message flow of ALTO/SSE, which can be considered as a more general transport protocol than the ALTO base transport protocol.  Although ALTO/SSE allows the concurrent transport of multiple ALTO information resources, it has complexities and limitations. For example, it requires that the server provide a separate control URI, leading to complexity in management; it needs its own envelop protocol on top of HTTP encoding to indicate message types.
      </t>
      <figure anchor="FigOverview">
        <name>ALTO SSE Architecture and Message Flow.</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
    
 ------------------------------------------------------------------
|                                                                  |
|          +-------+         +-------+ 1. init request  +------+   |
|          |       |         |       | <-------------   |      |   |
|          |       |         |       | ------------->   |      |   |
| 3.add/   |       |         |       | 1'. control uri  |      |   |
| remove   |       |         |       |                  |      |   |
| resource |Stream |         |Update |                  |      |   |
  -------->|Control| private |Stream | 2a. data update  |Client| --
           |Server |<------->|Server | messages         |      |
  -------- |       |         |       | -------------->  |      | <-
| response |       |         |       | -------------->  |      |   |
|          |       |         |       | 2b.control update|      |   |
|          +-------+         +-------+ messages         +------+   |
|                                                                  |
 ------------------------------------------------------------------
    
    ]]></artwork>
      </figure>
      <t>This document specifies ALTO New Transport, which realizes ALTO/SSE functions but takes advantage of newer versions of HTTP (e.g., HTTP/2 <xref target="RFC7540" format="default"/>) that support concurrent, non-blocking transport of multiple streams in the same HTTP connection.</t>
    </section>

    <section anchor="altoh2req" numbered="true" toc="default">
      <name>ALTO New Transport Design Requirements</name>
      <t>ALTO New Transport is designed to satisfy a set of requirements. First, it should satisfy the following requirements to realize the functions of ALTO/SSE:</t>
      <ul spacing="normal">
        <li>R0: Client can request any resource using the connection, just as using ALTO base protocol using HTTP/1.x.</li>
        <li>R1: The client can request the addition (start) of incremental updates to a resource.</li>
        <li>R2: The client can request the deletion (stop) of incremental updates to a resource.</li>
        <li>R3: The server can signal to the client the start or stop of incremental updates to a resource.</li>
        <li>R4: The server can choose the type of each incremental update encoding, as long as the type is indicated to be acceptable by the client.</li>
      </ul>
      <t>Following the ALTO framework <xref target="RFC7285" format="default"/> <xref target="RFC7971" format="default"/>, ALTO New Transport should still be HTTP based:</t>
      <ul spacing="normal">
        <li>R5: The design follows the basic principle of HTTP---Representational State Transfer and
          hence can use only HTTP verbs (GET, POST, PUT, DELETE, HEAD).</li>
      </ul>

      <t>ALTO New Transport should be designed to take advantage of newer HTTP design features, in particular, parallel transfers, but be as transparent to versions (HTTP/2, HTTP/3) as possible. If a design is based on a particular HTTP version, it should respect its semantics:</t>
      <ul spacing="normal">      
        <li>R6: The design respects specific HTTP semantics such as the semantics of PUSH_PROMISE, if the feature is used.</li>
      </ul>

      <t>To allow flexible deployment, the new transport protocol should be flexible, in particular, </t>
      <ul spacing="normal">
        <li>R7: The design should support capability negotiation.</li>
      </ul>
    </section>
    <section anchor="altoh2overview" numbered="true" toc="default">
      <name>ALTO New Transport Design Overview</name>
      <t>A key design of ALTO New Transport is to distinguish between information about ALTO resources and information about ALTO transport. The latter information is called transport management information, which provides meta information about the transport of ALTO information resources:</t>
      <ul spacing="normal">
        <li>The transport state from the ALTO server to an ALTO client (or a set of clients) for
        an ALTO information resource is conceptually through a transport 
        queue. A static ALTO information resource (e.g., Cost Map, Network Map) has a single transport queue, and a dynamic ALTO information resource (e.g., Filtered Cost Map) may create a queue for each unique filter request.</li>

        <li>The base transport queue defined in this document includes only a single element: the incremental update message queue, which includes a sequence of incremental update messages. A particular transport design may extend the base design to include additional state. For example, the server-push design <xref target="draft-schott-alto-new-transport-push" format="default"/> may include the additional receiver set state, which includes the set of receivers receiving incremental push updates from the ALTO server. </li>

        <li>The transport queue state is exposed to clients through views; that is, a client can see only a virtual view of the server state.</li>
      </ul>

      <t>Figure 2 shows an example illustrating the aforementioned information. It includes the additional receiver-set state, to illustrate the possibility of extension. Each ALTO client 
        (Client 1, Client 2, or Client 3) maintains a single HTTP connection with the ALTO server.
      </t>
      <figure anchor="FigInfoStruct">
        <name>ALTO New Transport Transport Management Information.</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
    
Information Resource:

a) Static resource (#1) such as NetworkMap
b) Filterable resource (#3) such as FilteredCostMap


                              +-------------+
                              |             |
         +--------------------| ALTO Server |-----------+
         |                  +-|             |-+         |
         |                  | +-------------+ |         |
         |                  |                 |         |
---------|------------------|-----------------|---------|------------
         |                  |                 |         | Information
         |                  |                 |         | Resource
+-------------+   +-------------+   +-------------+   +-------------+ 
| Information |   | Information |   | Information |   | Information | 
| Resource #1 |   | Resource #2 |   | Resource #3 |   | Resource #4 | 
+-------------+   +-------------+   +-------------+   +-------------+ 
       |                              /    \
-------|-----------------------------/------\------------------------ 
       |                            /        \            Transport
       |                      +----/          \------+    Queues
       |                      |                      |
  +--------+             +--------+             +--------+
  |   tq1  |-----+       |   tq2  |-----+       |   tq3  |-----+
  +----|---+     |       +----|---+     |       +----|---+     |
       |         |            |         |            |         |
  +----|---+ +---|----+  +----|---+ +---|----+  +----|---+ +---|----+
  | tq1/uq | | tq1/rs |  | tq2/uq | | tq2/rs |  | tq3/uq | | tq3/rs |
  +--------+ +--------+  +--------+ +--------+  +--------+ +--------+
       |\       /\              |         /           |          |
-------|-\-----/--\-------------|--------/------------|----------|---
       |  \   /    +-------+    |       /             |          |
       |   +-/-----------+  \   |      /              |          |
       |    /             \  \  |     /   A           +          +
       |   /            +--\--\-|----/--+ single       \        /
       |  /             +---\--\|---/---+ http2/3       \      /
   +----------+             +----------+  connection   +----------+
   | Client 1 |             | Client 2 |               | Client 3 |
   +----------+             +------- --+               +----------+

tqi    = transport queue i
tqi/uq = incremental updates queue of transport queue i
tqi/rs = receiver set of transport queue i
    
      ]]></artwork>
      </figure>

      <t>The basic work flow of a client connecting to an ALTO server is the following:</t>
      <figure anchor="FigInfoWorkflow">
        <name>ALTO New Transport Workflow.</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
    

    Client opens a connection to the server
    Client opens/identifies a transport queue tq
      // pull mode
      Client requests transport queue status of tq
      Client requests an element in the incremental update queue

      // push mode
      Client becomes a receiver
      Client receives incremental push updates
    Client closes the transport queue tq
    Client closes the connection
    
      ]]></artwork>
      </figure>
    </section>
    <!-- End of overview section -->

    <section anchor="altoh2tq" numbered="true" toc="default">
      <name>Transport Information: Transport Queue</name>
      <section anchor="altoh2tqops" numbered="true" toc="default">
        <name>Transport Queue Operations</name>
        <t>A transport queue supports three basic operations (CRD): create, read 
        (get status), and delete.
        </t>
        <t>Create a transport queue: An ALTO client creates a transport queue using the HTTP POST method with ALTO SSE AddUpdateReq 
        ([RFC 8895] Sec. 6.5) as the parameter: 
        </t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
      
    object {
        ResourceID   resource-id;
        [JSONString  tag;]
        [Boolean     incremental-changes;]
        [Object      input;]
     } AddUpdateReq;

          
        ]]></artwork>
        <t>In the base design, the client should not include the incremental-changes field.</t>
        <t>A successful POST request MUST return the URI for the transport queue. </t>

        <t>Read a transport queue: A client reads the status of a transport queue by issuing a GET request to the transport queue URI returned from the POST method. </t>

        <t>Delete a transport queue: a transport queue exposed to a client can be closed (deleted) either explicitly or implicitly.</t>
        <ul spacing="normal">
          <li>Explicit delete: A client uses the HTTP DELETE method to explicitly delete a transport 
          queue. If successful, the transport queue is deleted from the local view of the client, although the server may still maintain the transport queue for other client connections.
          </li>
          <li>Implicit delete: Transport queue for a client is ephemeral: the close of the HTTP connection between the client and the server deletes the transport queue from the client's view --- when the client reconnects, the client MUST NOT assume that the transport queue is still valid.
          </li>
        </ul>
        <t>Error codes: ALTO New Transport uses HTTP error codes.</t>
      </section>
      <!-- transport queue section operation -->

      <section anchor="altoh2tqexamples" numbered="true" toc="default">
        <name>Examples</name>
        <t>The first example is a client creating a transport queue.</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   Client -> server request

   HEADERS
     - END_STREAM
     + END_HEADERS
       :method = POST
       :scheme = https
       :path = /tqs
       host = alto.example.com
       accept = application/alto-error+json,
                    application/alto-transport+json
       content-type = application/alto-transport+json
       content-length = TBD

   DATA
    - END_STREAM
    {
       "resource-id": "my-routingcost-map"
    }
          
        ]]></artwork>
        <artwork name="" type="" align="left" alt=""><![CDATA[

   Server -> client response:

   HEADERS
     - END_STREAM
     + END_HEADERS
       :status = 200
       content-type = application/alto-transport+json
       content-length = TBD
   
   DATA
     - END_STREAM
      {"tq": “/tqs/2718281828459”}

          
        ]]></artwork>
        <t>The client can then read the status of the transport queue using the read operation 
          (GET) in the same HTTP connection. Below is an example (structure of incremental updates queue will be specified in the next section):</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   Client -> server request

   HEADERS
     - END_STREAM
     + END_HEADERS
       :method = GET
       :scheme = https
       :path = /tqs/2718281828459
       host = alto.example.com
       accept = application/alto-error+json,
                    application/alto-transport+json

   Server -> client response:

   HEADERS
     - END_STREAM
     + END_HEADERS
       :status = 200
       content-type = application/alto-transport+json
       content-length = TBD
   
   DATA
     - END_STREAM
    { "uq":
       [ 
         {“seq”:        101, 
          "media-type": "application/alto-costmap+json",
          “tag”:        "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe" }, 
         {“seq”:        102, 
          "media-type": "application/merge-patch+json",
          “tag”:        "cdf0222x59740b0b2e3f8eb1d4785acd42231bfe" },
         {“seq”:        103, 
          "media-type": "application/merge-patch+json",
          “tag”:        "8eb1d4785acd42231bfecdf0222x59740b0b2e3f",
          "link":       "/tqs/2718281828459/snapshot/2e3f"} 
 
       ]
    }

          ]]></artwork>
      </section>
    </section>
    <!-- transport queue section -->

    <section anchor="altoh2uq" numbered="true" toc="default">
      <name>Transport Information: Incremental Updates Queue</name>
      <section anchor="altoh2uqops" numbered="true" toc="default">
        <name>Incremental Updates Queue Operations</name>
        <t>Among the CRUD operations, an incremental updates queue supports only the 
          read operation: a client cannot create, update, or delete incremental updates queue directly---it is read only, and associated with transport queue automatically.</t>
        <t>Reads an incremental updates queue: A client reads the status of an incremental updates queue using the HTTP GET method: GET transport-queue-uri/uq, where the transport-queue-uri is
        the URI returned in the transport queue create method.
        </t>
        <t>The response informs the client the backlog status, and potential direct links.
          Specifically, the response is a JSON array, with each element being one incremental 
          update, with three required fields and one optional field:</t>
        <ul spacing="normal">
          <li>"seq": a required JSON integer indicating the sequence number of the incremental update; As JSON allows a large integer space, when the server reaches the largest integer, the server SHOULD close the incremental update queue; </li>
          <li>"media-type", a required JSON string giving the type of the incremental update  (see ALTO/SSE);</li>
          <li>"tag": a required JSON string giving a unique tag (see [RFC7285]; </li>
          <li>"link": an optional JSON string giving an optional link for a client to directly request a resource as a complete snapshot (not through incremental updates).</li>
        </ul>
        <t>Note that the server determines the state (window of history and type of each update) 
          in the incremental updates queue, as specified by [R4].</t>
      </section>
      <section anchor="altoh2uqexamples" numbered="true" toc="default">
        <name>Examples</name>
        <t>Assume the same example in the preceding section. The client can check the status of the incremental updates queue of a transport queue from the same connection:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   Client -> server request:

   HEADERS
     - END_STREAM
     + END_HEADERS
       :method = GET
       :scheme = https
       :path = /tqs/2718281828459/uq
       host = alto.example.com
       accept = application/alto-error+json,
                    application/alto-transport+json

   Server -> client response:

   HEADERS
     - END_STREAM
     + END_HEADERS
       :status = 200
       content-type = application/alto-transport+json
       content-length = TBD
   
   DATA
     - END_STREAM
    { 
       [ 
         {“seq”:        101, 
          "media-type": "application/alto-costmap+json",
          “tag”:        "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe" }, 
         {“seq”:        102, 
          "media-type": "application/merge-patch+json",
          “tag”:        "cdf0222x59740b0b2e3f8eb1d4785acd42231bfe" },
         {“seq”:        103, 
          "media-type": "application/merge-patch+json",
          “tag”:        "8eb1d4785acd42231bfecdf0222x59740b0b2e3f",
          "link":       "/tqs/2718281828459/snapshot/2e3f"} 
 
       ],
     
    }
          ]]></artwork>
      </section>
    </section>
    <!-- Incremental Update Message Queue Section -->

    <section anchor="altoh2updates" numbered="true" toc="default">
      <name>Information Resource Information: Client Pull Individual Updates</name>
      <section anchor="altoh2updatesops" numbered="true" toc="default">
        <name>Individual Updates Operations</name>
        <t>A client can only read an individual update: A client uses the HTTP GET method on the incremental updates queue concatenated by a sequence number to pull an individual update.The server push model, however,  depends on HTTP specific version.</t>
        
      </section>
      <section anchor="altoh2updatesexamples" numbered="true" toc="default">
        <name>Examples</name>
        <t>The first example is a client pull example, in which the client directly requests an 
          individual update. </t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   Client -> server request:

   HEADERS
     + END_STREAM
     + END_HEADERS
       :method = GET
       :scheme = https
       :path = /tqs/2718281828459/uq/101
       host = alto.example.com
       accept = application/alto-error+json,
                    application/alto-costmap+json

   Server -> client response:

   HEADERS
     - END_STREAM
     + END_HEADERS
       :status = 200
       content-type = application/alto-costmap+json
       content-length = TBD
   
   DATA
     + END_STREAM
    {
      "meta" : {
         "dependent-vtags" : [{
            "resource-id": "my-network-map",
            "tag": "da65eca2eb7a10ce8b059740b0b2e3f8eb1d4785"
          }],
         "cost-type" : {
           "cost-mode"  : "numerical",
           "cost-metric": "routingcost"
         },
         "vtag": {
           "resource-id" : "my-routingcost-map",
           "tag" : "3ee2cb7e8d63d9fab71b9b34cbf764436315542e"
         }
      },
      "cost-map" : {
        "PID1": { "PID1": 1,  "PID2": 5,  "PID3": 10 },
        "PID2": { "PID1": 5,  "PID2": 1,  "PID3": 15 },
        "PID3": { "PID1": 20, "PID2": 15  }
      }
   }

          ]]></artwork>
        <t>Note from the transport queue state that the 103 message has an OPTIONAL link to a complete snapshot, which a client can request.</t>

        <t>One important design is that the "seq" must be sequentially increasing. Hence, by issuing a request on the next sequence number, the client realizes long pull.</t>

      </section>
      <!-- individual example -->

    </section>
    <!-- individual -->

    <section anchor="altoh2streams" numbered="true" toc="default">
      <name>ALTO New Transport Stream Management</name>
      <section anchor="altoh2streamsobj" numbered="true" toc="default">
        <name>Objectives</name>
        <t>A main benefit of ALTO New Transport is to take advantage of concurrent streams in newer versions of HTTP (HTTP/2 and later). In particular, the objectives of ALTO New Transport include: </t>
        <ul spacing="normal">
          <li>Allow stream concurrency to reduce latency</li>
          <li>Minimize the number of streams created</li>
          <li>Enforce dependency among streams (so that if A depends on B, then A should be sent after B)</li>
          <li>Encode dependency to enforce semantics (correctness)</li>
        </ul>
        <t>To realize the objectives, ALTO New Transport MUST satisfy the following stream management requirements in all 4 phases specified in the next 4 subsections.</t>
      </section>
      <section anchor="altoh2streamcreatetq" numbered="true" toc="default">
        <name>Client -&gt; Server [Create Transport Queue]</name>
        <t>Each request to create a transport queue (POST) MUST choose a new client selected stream ID (SID_tq), with the following requirements:</t>
        <ul spacing="normal">
          <li>Stream Identifier of the frame is a new client-selected stream ID; Stream Dependency in HEADERS is 0 (connection) for an independent resource, the other transport queue if the dependency is known.</li>
          <li>Invariant: Stream keeps open until close or error.</li>
        </ul>
      </section>
      <section anchor="altoh2streamclosetq" numbered="true" toc="default">
        <name>Client -&gt; Server [Close Transport Queue]</name>
        <t>DELETE to close a transport queue (SID_tq) MUST be sent in SID_tq, with the following requirements:</t>
        <ul spacing="normal">
          <li>Stream Identifier of the frame is SID_tq, and Stream Dependency in HEADER is 0 
              (connection), so that a client cannot close a different stream.</li>
          <li>HEADERS indicates END_STREAM; server response SHOULD close the stream.</li>
        </ul>
      </section>
      <section anchor="altoh2streamread" numbered="true" toc="default">
        <name>Client -&gt; Server [Request on Data of a Transport Queue on Stream SID_tq]</name>
        <t>The request and response MUST satisfy the following requirements:</t>
        <ul spacing="normal">
          <li>The Stream Identifier of the frame is a new client-selected stream ID, and Stream Dependency in HEADERs MUST be SID_tq, so that a client cannot issue request on a closed transport queue;</li>
          <li>Both the request and the response MUST indicate END_STREAM.</li>
        </ul>
      </section>
      <section anchor="altoh2streamconc" numbered="true" toc="default">
        <name>Concurrency Management</name>
        <t/>
        <ul spacing="normal">
          <li>ALTO New Transport must allow concurrency control.</li>
          <li>From the client to the server direction, there MUST be one stream for each open transport 
              queue, and hence a client can always close a transport queue (which it uses to open the stream) and hence can also close, without the risk of deadlock.</li>
        </ul>
      </section>
    </section>
    <section anchor="altoh2ird" numbered="true" toc="default">
      <name>ALTO New Transport Information Resource Directory (IRD)</name>
      <t>Extending the IRD example in Section 8.1 of <xref target="RFC8895" format="default"/>, below is the IRD of an ALTO server supporting ALTO base protocol, ALTO/SSE, and ALTO New Transport.</t>
      <t>In particular, </t>
      <artwork name="" type="" align="left" alt=""><![CDATA[
  "my-network-map": {
    "uri": "https://alto.example.com/networkmap",
    "media-type": "application/alto-networkmap+json",
  },
  "my-routingcost-map": {
    "uri": "https://alto.example.com/costmap/routingcost",
    "media-type": "application/alto-costmap+json",
    "uses": ["my-networkmap"],
    "capabilities": {
      "cost-type-names": ["num-routingcost"]
    }
  },
  "my-hopcount-map": {
    "uri": "https://alto.example.com/costmap/hopcount",
    "media-type": "application/alto-costmap+json",
    "uses": ["my-networkmap"],
    "capabilities": {
      "cost-type-names": ["num-hopcount"]
    }
  },
  "my-filtered-cost-map": {
    "uri": "https://alto.example.com/costmap/filtered/constraints",
    "media-type": "application/alto-costmap+json",
    "accepts": "application/alto-costmapfilter+json",
    "uses": ["my-networkmap"],
    "capabilities": {
      "cost-type-names": ["num-routingcost", "num-hopcount"],
      "cost-constraints": true
    }
  },
  "my-simple-filtered-cost-map": {
    "uri": "https://alto.example.com/costmap/filtered/simple",
    "media-type": "application/alto-costmap+json",
    "accepts": "application/alto-costmapfilter+json",
    "uses": ["my-networkmap"],
    "capabilities": {
      "cost-type-names": ["num-routingcost", "num-hopcount"],
      "cost-constraints": false
    }
  },
  "my-props": {
    "uri": "https://alto.example.com/properties",
    "media-type": "application/alto-endpointprops+json",
    "accepts": "application/alto-endpointpropparams+json",
    "capabilities": {
      "prop-types": ["priv:ietf-bandwidth"]
    }
  },
  "my-pv": {
    "uri": "https://alto.example.com/endpointcost/pv",
    "media-type": "multipart/related;
                   type=application/alto-endpointcost+json",
    "accepts": "application/alto-endpointcostparams+json",
    "capabilities": {
      "cost-type-names": [ "path-vector" ],
      "ane-properties": [ "maxresbw", "persistent-entities" ]
    }
  },
  "update-my-costs": {
    "uri": "https://alto.example.com/updates/costs",
    "media-type": "text/event-stream",
    "accepts": "application/alto-updatestreamparams+json",
    "uses": [
       "my-network-map",
       "my-routingcost-map",
       "my-hopcount-map",
       "my-simple-filtered-cost-map"
    ],
    "capabilities": {
      "incremental-change-media-types": {
        "my-network-map": "application/json-patch+json",
        "my-routingcost-map": "application/merge-patch+json",
        "my-hopcount-map": "application/merge-patch+json"
      },
      "support-stream-control": true
    }
  },
  "update-my-costs-h2": {
    "uri": "https://alto.example.com/updates-h2/costs",
    "media-type": "application/alto-transport+json",
    "accepts": "application/alto-updatestreamparams+json",
    "uses": [
       "my-network-map",
       "my-routingcost-map",
       "my-hopcount-map",
       "my-simple-filtered-cost-map"
    ],
    "capabilities": {
      "incremental-change-media-types": {
        "my-network-map": "application/json-patch+json",
        "my-routingcost-map": "application/merge-patch+json",
        "my-hopcount-map": "application/merge-patch+json"
      },
      "support-stream-control": true
    }
  },

  "update-my-props": {
    "uri": "https://alto.example.com/updates/properties",
    "media-type": "text/event-stream",
    "uses": [ "my-props" ],
    "accepts": "application/alto-updatestreamparams+json",
    "capabilities": {
      "incremental-change-media-types": {
        "my-props": "application/merge-patch+json"
      },
      "support-stream-control": true
    }
  },
  "update-my-pv": {
    "uri": "https://alto.example.com/updates/pv",
    "media-type": "text/event-stream",
    "uses": [ "my-pv" ],
    "accepts": "application/alto-updatestreamparams+json",
    "capabilities": {
      "incremental-change-media-types": {
        "my-pv": "application/merge-patch+json"
      },
      "support-stream-control": true
    }
  }
  ]]></artwork>
      <t>Note that it is straightforward for an ALTO sever to run HTTP/2 and support concurrent retrieval of multiple resources such as "my-network-map" and "my-routingcost-map" using multiple HTTP/2 streams with the need to introducing ALTO/H2.</t>
      <t>The resource "update-my-costs-h2" provides an ALTO New Transport based connection, and this is indicated by the media-type "application/alto-transport+json". For an ALTO New Transport connection, the client can send in a sequence of control requests using media type application/alto-updatestreamparams+json. The server creates HTTP/2 streams and pushes updates to the client.</t>
    </section>
    <section anchor="secconsider" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>The properties defined in this document present no security
      considerations beyond those in Section 15 of the base ALTO specification
      [RFC7285].</t>
    </section>
    <section anchor="ianaconsider" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>IANA will need to register the application/alto-transport+json media type under ALTO registry as defined in 
        [RFC7285].</t>
    </section>
    <section numbered="true" toc="default">
      <name>Acknowledgments</name>
      <t>The authors of this document would also like to thank many
      for the reviews and comments.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <!-- requirements words -->
    <reference anchor="RFC7230" target="https://www.rfc-editor.org/info/rfc7230" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the "http" and "https" Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7230"/>
          <seriesInfo name="DOI" value="10.17487/RFC7230"/>
        </reference>
        <!-- HTTP/1.1 -->        
    <reference anchor="RFC7285" target="https://www.rfc-editor.org/info/rfc7285" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7285.xml">
          <front>
            <title>Application-Layer Traffic Optimization (ALTO) Protocol</title>
            <author initials="R." surname="Alimi" fullname="R. Alimi" role="editor">
              <organization/>
            </author>
            <author initials="R." surname="Penno" fullname="R. Penno" role="editor">
              <organization/>
            </author>
            <author initials="Y." surname="Yang" fullname="Y. Yang" role="editor">
              <organization/>
            </author>
            <author initials="S." surname="Kiesel" fullname="S. Kiesel">
              <organization/>
            </author>
            <author initials="S." surname="Previdi" fullname="S. Previdi">
              <organization/>
            </author>
            <author initials="W." surname="Roome" fullname="W. Roome">
              <organization/>
            </author>
            <author initials="S." surname="Shalunov" fullname="S. Shalunov">
              <organization/>
            </author>
            <author initials="R." surname="Woundy" fullname="R. Woundy">
              <organization/>
            </author>
            <date year="2014" month="September"/>
            <abstract>
              <t>Applications using the Internet already have access to some topology information of Internet Service Provider (ISP) networks.  For example, views to Internet routing tables at Looking Glass servers are available and can be practically downloaded to many network application clients.  What is missing is knowledge of the underlying network topologies from the point of view of ISPs.  In other words, what an ISP prefers in terms of traffic optimization -- and a way to distribute it.</t>
              <t>The Application-Layer Traffic Optimization (ALTO) services defined in this document provide network information (e.g., basic network location structure and preferences of network paths) with the goal of modifying network resource consumption patterns while maintaining or improving application performance.  The basic information of ALTO is based on abstract maps of a network.  These maps provide a simplified view, yet enough information about a network for applications to effectively utilize them.  Additional services are built on top of the maps.</t>
              <t>This document describes a protocol implementing the ALTO services. Although the ALTO services would primarily be provided by ISPs, other entities, such as content service providers, could also provide ALTO services.  Applications that could use the ALTO services are those that have a choice to which end points to connect.  Examples of such applications are peer-to-peer (P2P) and content delivery networks.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7285"/>
          <seriesInfo name="DOI" value="10.17487/RFC7285"/>
        </reference>
        <!-- alto base -->   
    <reference target="https://www.rfc-editor.org/info/rfc7540" anchor="RFC7540" xml:base="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7540.xml">
          <front>
            <title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
            <author fullname="M. Belshe" surname="Belshe" initials="M"/>
            <author fullname="R. Peon" surname="Peon" initials="R"/>
            <author fullname="M. Thomson" surname="Thomson" initials="M"/>
            <date year="2015" month="May"/>
            <abstract>
              <t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection. It also introduces unsolicited push of representations from servers to clients.</t>
              <t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax. HTTP's existing semantics remain unchanged.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7540"/>
          <seriesInfo name="DOI" value="10.17487/RFC7540"/>
        </reference>
        <!-- HTTP/2 -->     
    <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <!-- requirements words -->    
    <reference anchor="RFC8895" target="https://www.rfc-editor.org/info/rfc8895" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8895.xml">
          <front>
            <title>Application-Layer Traffic Optimization (ALTO) Incremental Updates Using Server-Sent Events (SSE)</title>
            <author initials="W." surname="Roome" fullname="W. Roome">
              <organization/>
            </author>
            <author initials="Y." surname="Yang" fullname="Y. Yang">
              <organization/>
            </author>
            <date year="2020" month="November"/>
            <abstract>
              <t>The Application-Layer Traffic Optimization (ALTO) protocol (RFC 7285) provides network-related information, called network information resources, to client applications so that clients can make informed decisions in utilizing network resources. This document presents a mechanism to allow an ALTO server to push updates to ALTO clients to achieve two benefits: (1) updates can be incremental, in that if only a small section of an information resource changes, the ALTO server can send just the changes and (2) updates can be immediate, in that the ALTO server can send updates as soon as they are available.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8895"/>
          <seriesInfo name="DOI" value="10.17487/RFC8895"/>
        </reference>
        <!-- ALTO SSE -->
    </references>
      <references>
        <name>Informative References</name>

          <reference anchor="draft-schott-alto-new-transport-push" target="https://datatracker.ietf.org/doc/draft-schott-alto-new-transport-push/">
          <front>
            <title>ALTO New Transport: Server Push</title>
            <author initials="R." surname="Schott" fullname="R. Schott">
              <organization/>
            </author>
            <author initials="Y." surname="Yang" fullname="Y. Yang">
              <organization/>
            </author>
            <date year="2022" month="October"/>
          </front>
          <seriesInfo name="Internet Draft" value="ID"/>
        </reference>

        <reference anchor="RFC7971" target="https://www.rfc-editor.org/info/rfc7971" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7971.xml">
          <front>
            <title>Application-Layer Traffic Optimization (ALTO) Deployment Considerations</title>
            <author initials="M." surname="Stiemerling" fullname="M. Stiemerling">
              <organization/>
            </author>
            <author initials="S." surname="Kiesel" fullname="S. Kiesel">
              <organization/>
            </author>
            <author initials="M." surname="Scharf" fullname="M. Scharf">
              <organization/>
            </author>
            <author initials="H." surname="Seidel" fullname="H. Seidel">
              <organization/>
            </author>
            <author initials="S." surname="Previdi" fullname="S. Previdi">
              <organization/>
            </author>
            <date year="2016" month="October"/>
            <abstract>
              <t>Many Internet applications are used to access resources such as pieces of information or server processes that are available in several equivalent replicas on different hosts.  This includes, but is not limited to, peer-to-peer file sharing applications.  The goal of Application-Layer Traffic Optimization (ALTO) is to provide guidance to applications that have to select one or several hosts from a set of candidates capable of providing a desired resource. This memo discusses deployment-related issues of ALTO.  It addresses different use cases of ALTO such as peer-to-peer file sharing and Content Delivery Networks (CDNs) and presents corresponding examples. The document also includes recommendations for network administrators and application designers planning to deploy ALTO, such as recommendations on how to generate ALTO map information.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7971"/>
          <seriesInfo name="DOI" value="10.17487/RFC7971"/>
        </reference>
        <!-- requirements -->

    </references>
    </references>
    <section numbered="true" toc="default">
      <name>Outlook to ALTO with HTTP/3</name>
      <t>This draft is focusing on HTTP/2 enhancement of the ALTO protocol and the 
design takes advantage of HTTP/2 design features such as parallel transfer 
and respects HTTP/2 semantics (e.g., PUSH_PROMISE). Since QUIC and HTTP/3 
respectively are coming up for various protocols on the Internet it is 
understandable that the question arises, if ATLO could also take 
advantage of the advantages of HTTP/3. QUIC can be seen as a replacement 
for TCP+TLS+HTTP2. HTTP/3 bases on the QUIC transport protocol and uses 
UDP instead of a TCP connection.</t>
      <t>QUIC has been developed by the IETF QUIC Working Group with the 
following goals:</t>
      <ul spacing="normal">
        <li>Minimizing connection establishment and overall transport latency for applications, starting with HTTP/2</li>
        <li>Providing multiplexing without head-of-line blocking</li>
        <li>Requiring only changes to path endpoints to enable deployment</li>
        <li>Enabling multipath and forward error correction extensions</li>
        <li>Providing always-secure transport, using TLS 1.3 by default</li>
      </ul>
      <t>If HTTP/3 is not supported, it automatically runs on HTTP/2. 
The prerequisite for HTTP/3 is that both client and server support it.</t>
      <t>The basic assumption is that an implementation that runs on HTTP/2 should 
also run-on HTTP/3. This should be transparent. 
HTTP/3 uses "well known port" UDP 443 analogous to TCP 443. 
The network between client and server must not filter HTTP/3.</t>
      <t>Since many applications still using HTTP/2 it is mandatory for ALTO 
to support this protocol first. This ensures compatibility. 
Therefore, this document describes the update of ALTO from HTTP/1.x 
to HTTP/2. The usage of HTTP/3 will be described in a separate 
document so that compatibility of ALTO with HTTP/3 will be ensured 
in a later stage.</t>
    </section>
  </back>
</rfc>
